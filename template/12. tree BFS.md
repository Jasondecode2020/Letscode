## template: 1302. Deepest Leaves Sum

```python
from collections import deque

def fn(root):
    q = deque([root])
    while queue:
        # some code
        # res = 0
        for _ in range(len(q)):
            node = queue.popleft()
            # some code
            # res += node.val
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
    return res
```

### Level order traversal

* `117. Populating Next Right Pointers in Each Node II`
* `1161. Maximum Level Sum of a Binary Tree`
* `1302. Deepest Leaves Sum`
* `2415. Reverse Odd Levels of Binary Tree`

### 117. Populating Next Right Pointers in Each Node II

```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        res, q = [], deque([root])
        while q:
            level = []
            for i in range(len(q)):
                node = q.popleft()
                level.append(node)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            for i in range(len(level) - 1):
                level[i].next = level[i + 1]
        return root
```

### 1161. Maximum Level Sum of a Binary Tree

```python
class Solution:
    def maxLevelSum(self, root: Optional[TreeNode]) -> int:
        q, res = deque([root]), []
        while q:
            level = []
            for i in range(len(q)):
                node = q.popleft()
                level.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(sum(level))
    
        maxNum = max(res)
        for i, n in enumerate(res):
            if n == maxNum:
                return i + 1
```

### 1302. Deepest Leaves Sum

```python
from collections import deque
class Solution:
    def deepestLeavesSum(self, root: Optional[TreeNode]) -> int:
        q = deque([root])
        while q:
            total = 0
            for i in range(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        return total
```

### 2415. Reverse Odd Levels of Binary Tree

```python
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def check(res):
            val = [r.val for r in res]
            val.reverse()
            for node, val in zip(res, val):
                node.val = val

        q, odd = deque([root]), True
        while q:
            level = []
            odd = not odd
            for i in range(len(q)):
                node = q.popleft()
                level.append(node)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if odd:
                check(level)
        return root
```

### 1609. Even Odd Tree

```python
class Solution:
    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
        q, even = deque([root]), True
        while q:
            level = []
            for i in range(len(q)):
                node = q.popleft()
                level.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if even and (any(n % 2 == 0 for n in level) or level != sorted(level)) :
                return False
            if not even and (any(n % 2 == 1 for n in level) or level != sorted(level, reverse = True)):
                return False
            if len(level) != len(set(level)):
                return False
            even = not even
        return True
```