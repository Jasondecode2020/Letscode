## template 1

```python
from collections import deque

def fn(g): # graph
    q = deque([START_NODE]) # q: deque
    visited = {START_NODE}
    res = 0

    while q:
        node = q.popleft()
        # some code
        for neighbor in g[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                q.append(neighbor)
    return res
```

## template 2: 994. Rotting Oranges

```python
def fn(q):
    while q:
        r, c, t = q.popleft()
        res = max(res, t)
        for dr, dc in directions:
            row, col = r + dr, c + dc 
            if 0 <= row < R and 0 <= col < C and (row, col) and grid[row][col] == 1:
                q.append((row, col, t + 1))
                grid[row][col] = 2
```

## tempalte: multi-source

- 1 find multi-source
- 2 prepare q or visited set
- 3 normal bfs using template 2


## Vinilla BFS

- 815. Bus Routes

## Multi-source BFS

- 994. Rotting Oranges
- 286. Walls and Gates

### 815. Bus Routes

```python
class Solution:
    def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
        g = defaultdict(list) # stop: [bus]
        for bus, route in enumerate(routes):
            for stop in route:
                g[stop].append(bus)
        
        q = deque([(source, 0)])
        buses = [set(r) for r in routes]
        visited_bus, visited_stop = set(), set([source])
        while q:
            stop, cost = q.popleft()
            if stop == target:
                return cost
            for bus in g[stop]:
                if bus not in visited_bus:
                    visited_bus.add(bus)
                    for s in buses[bus]:
                        if s not in visited_stop:
                            visited_stop.add(s)
                            q.append((s, cost + 1))
        return -1
```

### 994. Rotting Oranges

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        q = deque()
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        R, C = len(grid), len(grid[0])
        for r in range(R):
            for c in range(C):
                if grid[r][c] == 2:
                    q.append((r, c, 0))

        res = 0
        while q:
            r, c, t = q.popleft()
            res = max(res, t)
            for dr, dc in directions:
                row, col = r + dr, c + dc 
                if 0 <= row < R and 0 <= col < C and (row, col) and grid[row][col] == 1:
                    q.append((row, col, t + 1))
                    grid[row][col] = 2

        if any(1 in r for r in grid):
            return -1
        return res
```

### 286. Walls and Gates

```python
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        R, C, INF = len(rooms), len(rooms[0]), 2147483647
        q = deque()
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for r in range(R):
            for c in range(C):
                if rooms[r][c] == 0:
                    q.append((r, c))

        while q:
            r, c = q.popleft()
            for dr, dc in directions:
                row, col = r + dr, c + dc
                if 0 <= row < R and 0 <= col < C and rooms[row][col] == INF:
                    q.append((row, col))
                    rooms[row][col] = rooms[r][c] + 1
        return rooms
```

### 1020. Number of Enclaves

```python
class Solution:
    def numEnclaves(self, grid: List[List[int]]) -> int:
        q = deque()
        R, C = len(grid), len(grid[0])
        for r in range(R):
            for c in range(C):
                if (r == 0 or r == R - 1 or c == 0 or c == C - 1) and grid[r][c] == 1:
                    q.append((r, c))
                    grid[r][c] = 0
        
        direction = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            r, c = q.popleft()
            for dr, dc in direction:
                row, col = r + dr, c + dc
                if 0 <= row < R and 0 <= col < C and grid[row][col] == 1:
                    grid[row][col] = 0
                    q.append((row, col))
        return sum(grid[r][c] for r in range(R) for c in range(C))
```

### 752. Open the Lock

- can be optimized by bidirectional bfs

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        def check(s):
            d, res = defaultdict(list), []
            for c in [str(i) for i in range(0, 10)]:
                s1, s2 = '0', '9'
                if c != '9':
                    s1 = str(int(c) + 1)
                if c != '0':
                    s2 = str(int(c) - 1)
                d[c].extend([s1, s2])
            for i, c1 in enumerate(s):
                for c2 in d[c1]:
                    res.append(s[:i] + c2 + s[i + 1:])
            return res

        q = deque([('0000', 0)])
        visited = set(deadends)
        if '0000' in visited:
            return -1
        while q:
            s, cost = q.popleft()
            if s == target:
                return cost
            for child in check(s):
                if child not in visited:
                    visited.add(child)
                    q.append((child, cost + 1))
        return -1
```

### 127. Word Ladder

- can be optimized by bidirectional bfs

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        def check(word):
            res = []
            for i, c in enumerate(word):
                for l in ascii_lowercase:
                    if l != c:
                        res.append(word[:i] + l + word[i + 1:])
            return res

        wordList = set(wordList)
        q = deque([(beginWord, 1)])
        visited = set([beginWord])
        while q:
            begin, cost = q.popleft()
            if begin == endWord:
                return cost
            for word in check(begin):
                if word not in visited and word in wordList:
                    visited.add(word)
                    q.append((word, cost + 1))
        return 0
```

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordDict = set(wordList)
        if endWord not in wordDict: 
            return 0
        l, s1, s2 = len(beginWord), {beginWord}, {endWord}
        wordDict.remove(endWord)
        step = 1
        while s1 and s2:
            step += 1
            if len(s1) > len(s2): s1, s2 = s2, s1
            s = set()   
            for w in s1:
                new_words = [w[:i] + t + w[i+1:] for t in string.ascii_lowercase for i in range(l)]
                for new_word in new_words:
                    if new_word in s2: 
                        return step
                    if new_word in wordDict: 
                        wordDict.remove(new_word)                        
                        s.add(new_word)
            s1 = s
        return 0
```