## template: permutations

```python
def permute(self, nums: List[int]) -> List[List[int]]:
    res = []
    def backtrack(nums, path):
        if not nums:
            res.append(path[::])
            return 
        for i in range(len(nums)):
            path.append(nums[i])
            backtrack(nums[: i] + nums[i + 1: ], path)
            path.pop()

    backtrack(nums, [])
    return res
```

### 46. Permutations

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                path.append(nums[i])
                backtrack(nums[: i] + nums[i + 1: ], path)
                path.pop()
    
        backtrack(nums, [])
        return res
```

### 47. Permutations II

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]: # trimming
                    continue
                path.append(nums[i])
                backtrack(nums[: i] + nums[i + 1: ], path)
                path.pop()
    
        backtrack(sorted(nums), []) # sort to avoid duplicate
        return res
```

### 996. Number of Squareful Arrays

```python
class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        def is_perfect_square(n):
            return pow(int(sqrt(n)), 2) == n

        self.res = 0
        def backtrack(nums, path):
            if not nums:
                self.res += 1
                return
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]:
                    continue
                if not path or is_perfect_square(path[-1] + nums[i]):
                    path.append(nums[i])
                    backtrack(nums[: i] + nums[i + 1: ], path)
                    path.pop()
                    
        backtrack(sorted(nums), [])
        return self.res
```

### 679. 24 Game

```python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3
        def backtrack(nums):
            if len(nums) == 1:
                return math.isclose(nums[0], 24) == True
            for i, x in enumerate(nums):
                for j, y in enumerate(nums):
                    if i != j:
                        res = []
                        for k, z in enumerate(nums):
                            if k != i and k != j:
                                res.append(z)
                        for k in range(4):
                            if k == ADD:
                                res.append(x + y)
                            elif k == MULTIPLY:
                                res.append(x * y)
                            elif k == SUBTRACT:
                                res.append(x - y)
                            elif k == DIVIDE:
                                res.append(y and x / y)
                            if backtrack(res):
                                return True
                            res.pop()
            return False
        return backtrack(cards)
```