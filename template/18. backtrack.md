## template: backtracking

- terminations (res)
- tracking (dfs)
- trimming (timing)

### Backtracking

* [17. Letter Combinations of a Phone Number](#17-Letter-Combinations-of-a-Phone-Number)
* `22. Generate Parentheses`
* `37. Sudoku Solver`
* `39. Combination Sum`
* `40. Combination Sum II`
* `216. Combination Sum III`
* `377. Combination Sum IV`
* `46. Permutations`
* `47. Permutations II`
* `996. Number of Squareful Arrays`
* `679. 24 Game`

```python
# permutations
def permute(self, nums: List[int]) -> List[List[int]]:
    res = []
    def backtrack(nums, path):
        if not nums:
            res.append(path[::])
            return 
        for i in range(len(nums)):
            path.append(nums[i])
            backtrack(nums[: i] + nums[i + 1: ], path)
            path.pop()

    backtrack(nums, [])
    return res
```

### 17. Letter Combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }

        res = ['']
        for digit in digits:
            temp = []
            for c in d[digit]:
                for item in res:
                    temp.append(item + c)
            res = temp
        return res if res[0] else []
```

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res, n = [], len(digits)
        def backtrack(i, cur):
            if len(cur) == n:
                if cur:
                    res.append(cur)
                return
            for c in d[digits[i]]:
                backtrack(i + 1, cur + c)

        backtrack(0, '')
        return res
```

### 22. Generate Parentheses

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def backtrack(open, close, ans):
            if open == close == n:
                res.append(ans)
                return 
            if open < n:
                backtrack(open + 1, close, ans + '(')
            if close < open:
                backtrack(open, close + 1, ans + ')')
        backtrack(0, 0, '')
        return res
```

### 37. Sudoku Solver

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows, cols, squares, q = defaultdict(set), defaultdict(set), defaultdict(set), deque([])
        for i in range(9):
            for j in range(9):
                if board[i][j] != ".":
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    squares[(i // 3, j // 3)].add(board[i][j])
                else:
                    q.append((i,j))

        def backtrack():
            if not q:
                self.valid = True
                return
            r, c = q[0]
            square = (r // 3, c // 3)
            for n in numbers: # try 9 ways
                if n not in (rows[r] | cols[c] | squares[square]):
                    board[r][c] = n
                    rows[r].add(n)
                    cols[c].add(n)
                    squares[square].add(n)
                    q.popleft()
                    backtrack()
                    if not self.valid: # backtrack
                        board[r][c] = "."
                        rows[r].remove(n)
                        cols[c].remove(n)
                        squares[square].remove(n)
                        q.appendleft((r,c))
        numbers = set([str(i) for i in range(1, 10)])
        self.valid = False
        backtrack()
```

### 39. Combination Sum

- backtracking

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res, n = [], len(candidates)
        def backtrack(idx, ans, cur):
            if cur == target:
                res.append(ans)
                return 
            if cur > target:
                return
            for i in range(idx, n):
                backtrack(i, ans + [candidates[i]], cur + candidates[i])
        backtrack(0, [], 0)
        return res
```

### 40. Combination Sum II

- backtracking

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res, n = [], len(candidates)
        candidates.sort()
        def backtrack(idx, ans, cur):
            if cur == target:
                res.append(ans)
                return 
            if cur > target:
                return
            for i in range(idx, n):
                # for each layer of backtracking, no duplicate
                if i > idx and candidates[i] == candidates[i - 1]: 
                    continue
                backtrack(i + 1, ans + [candidates[i]], cur + candidates[i])
        backtrack(0, [], 0)
        return res
```

### 216. Combination Sum III

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        nums, res = list(range(1, 10)), []
        L = len(nums)
        def backtrack(idx, ans, cur, length):
            if cur == n and length == k:
                res.append(ans)
                return
            if cur > n or length > k:
                return
            for i in range(idx, L):
                backtrack(i + 1, ans + [nums[i]], cur + nums[i], length + 1)
        backtrack(0, [], 0, 0)
        return res
```

### 377. Combination Sum IV

- backtrack not possible

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        self.res, n = 0, len(nums)
        def backtrack(idx, cur):
            if cur == target:
                self.res += 1
                return 
            if cur > target:
                return
            for i in range(0, n):
                backtrack(i, cur + nums[i])
        backtrack(0, 0)
        return self.res
```

- unbounded knapsack

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [1] + [0] * target
        for i in range(1, target + 1):
            for num in nums:
                if num <= i:
                    dp[i] += dp[i - num]
        return dp[-1]
```

### 46. Permutations

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                path.append(nums[i])
                backtrack(nums[: i] + nums[i + 1: ], path)
                path.pop()
    
        backtrack(nums, [])
        return res
```

### 47. Permutations II

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]: # trimming
                    continue
                path.append(nums[i])
                backtrack(nums[: i] + nums[i + 1: ], path)
                path.pop()
    
        backtrack(sorted(nums), []) # sort to avoid duplicate
        return res
```

### 996. Number of Squareful Arrays

```python
class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        def is_perfect_square(n):
            return pow(int(sqrt(n)), 2) == n

        self.res = 0
        def backtrack(nums, path):
            if not nums:
                self.res += 1
                return
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]:
                    continue
                if not path or is_perfect_square(path[-1] + nums[i]):
                    path.append(nums[i])
                    backtrack(nums[: i] + nums[i + 1: ], path)
                    path.pop()
                    
        backtrack(sorted(nums), [])
        return self.res
```

### 679. 24 Game

```python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3
        def backtrack(nums):
            if len(nums) == 1:
                return math.isclose(nums[0], 24) == True
            for i, x in enumerate(nums):
                for j, y in enumerate(nums):
                    if i != j:
                        res = []
                        for k, z in enumerate(nums):
                            if k != i and k != j:
                                res.append(z)
                        for k in range(4):
                            if k == ADD:
                                res.append(x + y)
                            elif k == MULTIPLY:
                                res.append(x * y)
                            elif k == SUBTRACT:
                                res.append(x - y)
                            elif k == DIVIDE:
                                res.append(y and x / y)
                            if backtrack(res):
                                return True
                            res.pop()
            return False
        return backtrack(cards)
```