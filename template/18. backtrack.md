## template: backtracking

- terminations (res)
- tracking (dfs)
- trimming (timing)


```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]: # 46. Permutations
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                backtrack(nums[: i] + nums[i + 1: ], path + [nums[i]])
        res = []
        backtrack(nums, [])
        return res
```

### Backtracking

> without for pattern
* [257. Binary Tree Paths](#257-Binary-Tree-Paths)[E]
* [988. Smallest String Starting From Leaf](#988-Smallest-String-Starting-From-Leaf)[M][same as 257]
* [113. Path Sum II](#113-Path-Sum-II)[M][same as 257]
> basic for pattern
* [17. Letter Combinations of a Phone Number](#17-Letter-Combinations-of-a-Phone-Number)
* [22. Generate Parentheses](#22-Generate-Parentheses)
* [37. Sudoku Solver](#37-Sudoku-Solver)
* [`39. Combination Sum`](#39-Combination-Sum)
* [`40. Combination Sum II`](#40-Combination-Sum-II)
* [216. Combination Sum III](#216-Combination-Sum-III)
* [377. Combination Sum IV](#377-Combination-Sum-IV)
* [`46. Permutations`](#46-Permutations)
* [`47. Permutations II`](#47-Permutations-II)
* `996. Number of Squareful Arrays`
* `679. 24 Game`

### 257. Binary Tree Paths

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def check(res):
            for i, a in enumerate(res):
                a = [str(c) for c in a]
                res[i] = '->'.join(a)
            return res
            
        self.res = []
        def backtrack(node, path): # preorder traversal/backtrack
            if node:
                if not node.left and not node.right: # find leaf
                    self.res.append(path + [node.val])
                    return
                backtrack(node.left, path + [node.val])
                backtrack(node.right, path + [node.val])
        backtrack(root, [])
        return check(self.res)
```

### 988. Smallest String Starting From Leaf

- only change check function

```python
class Solution:
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:
        letters = ascii_lowercase
        def check(res):
            for i, a in enumerate(res):
                res[i] = ''.join([letters[i] for i in a])
            return sorted(res)[0]
            
        self.res = []
        def backtrack(node, path):
            if node:
                if not node.left and not node.right:
                    self.res.append([node.val] + path)
                    return
                backtrack(node.left, [node.val] + path)
                backtrack(node.right, [node.val] + path)
        backtrack(root, [])
        return check(self.res)
```

### 113. Path Sum II

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        def backtrack(node, path, presum):
            if node:
                if not node.left and not node.right and presum + node.val == targetSum:
                    res.append(path + [node.val])
                backtrack(node.right, path + [node.val], presum + node.val)
                backtrack(node.left, path + [node.val], presum + node.val)
            return res
        return backtrack(root, [], 0)
```

### 17. Letter Combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }

        res = ['']
        for digit in digits:
            temp = []
            for c in d[digit]:
                for item in res:
                    temp.append(item + c)
            res = temp
        return res if res[0] else []
```

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res, n = [], len(digits)
        def backtrack(i, cur):
            if len(cur) == n:
                if cur:
                    res.append(cur)
                return
            for c in d[digits[i]]:
                backtrack(i + 1, cur + c)

        backtrack(0, '')
        return res
```

### 22. Generate Parentheses

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def backtrack(open, close, ans):
            if open == close == n:
                res.append(ans)
                return 
            if open < n:
                backtrack(open + 1, close, ans + '(')
            if close < open:
                backtrack(open, close + 1, ans + ')')
        backtrack(0, 0, '')
        return res
```

### 37. Sudoku Solver

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows, cols, squares, q = defaultdict(set), defaultdict(set), defaultdict(set), deque([])
        for i in range(9):
            for j in range(9):
                if board[i][j] != ".":
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    squares[(i // 3, j // 3)].add(board[i][j])
                else:
                    q.append((i,j))

        def backtrack():
            if not q:
                self.valid = True
                return
            r, c = q[0]
            square = (r // 3, c // 3)
            for n in numbers: # try 9 ways
                if n not in (rows[r] | cols[c] | squares[square]):
                    board[r][c] = n
                    rows[r].add(n)
                    cols[c].add(n)
                    squares[square].add(n)
                    q.popleft()
                    backtrack()
                    if not self.valid: # backtrack
                        board[r][c] = "."
                        rows[r].remove(n)
                        cols[c].remove(n)
                        squares[square].remove(n)
                        q.appendleft((r,c))
        numbers = set([str(i) for i in range(1, 10)])
        self.valid = False
        backtrack()
```

### 39. Combination Sum

- backtracking

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res, n = [], len(candidates)
        def backtrack(idx, ans, cur):
            if cur == target:
                res.append(ans)
                return 
            if cur > target:
                return
            for i in range(idx, n):
                backtrack(i, ans + [candidates[i]], cur + candidates[i])
        backtrack(0, [], 0)
        return res
```

### 40. Combination Sum II

- backtracking

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res, n = [], len(candidates)
        candidates.sort()
        def backtrack(idx, ans, cur):
            if cur == target:
                res.append(ans)
                return 
            if cur > target:
                return
            for i in range(idx, n):
                # for each layer of backtracking, no duplicate
                if i > idx and candidates[i] == candidates[i - 1]: 
                    continue
                backtrack(i + 1, ans + [candidates[i]], cur + candidates[i])
        backtrack(0, [], 0)
        return res
```

### 46. Permutations

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                backtrack(nums[: i] + nums[i + 1: ], path + [nums[i]])
        res = []
        backtrack(nums, [])
        return res
```

### 47. Permutations II

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(nums, path):
            if not nums:
                res.append(path[::])
                return 
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]: # trim branch, check duplicate
                    continue
                backtrack(nums[: i] + nums[i + 1: ], path + [nums[i]])
        backtrack(sorted(nums), []) # sort to avoid duplicate
        return res
```

### 216. Combination Sum III

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        nums, res = list(range(1, 10)), []
        L = len(nums)
        def backtrack(idx, ans, cur, length):
            if cur == n and length == k:
                res.append(ans)
                return
            if cur > n or length > k:
                return
            for i in range(idx, L):
                backtrack(i + 1, ans + [nums[i]], cur + nums[i], length + 1)
        backtrack(0, [], 0, 0)
        return res
```

### 377. Combination Sum IV

- backtrack not possible

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        self.res, n = 0, len(nums)
        def backtrack(idx, cur):
            if cur == target:
                self.res += 1
                return 
            if cur > target:
                return
            for i in range(0, n):
                backtrack(i, cur + nums[i])
        backtrack(0, 0)
        return self.res
```

- unbounded knapsack

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [1] + [0] * target
        for i in range(1, target + 1):
            for num in nums:
                if num <= i:
                    dp[i] += dp[i - num]
        return dp[-1]
```

### 996. Number of Squareful Arrays

```python
class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        def is_perfect_square(n):
            return pow(int(sqrt(n)), 2) == n

        self.res = 0
        def backtrack(nums, path):
            if not nums:
                self.res += 1
                return
            for i in range(len(nums)):
                if i > 0 and nums[i] == nums[i - 1]:
                    continue
                if not path or is_perfect_square(path[-1] + nums[i]):
                    path.append(nums[i])
                    backtrack(nums[: i] + nums[i + 1: ], path)
                    path.pop()
                    
        backtrack(sorted(nums), [])
        return self.res
```

### 679. 24 Game

```python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3
        def backtrack(nums):
            if len(nums) == 1:
                return math.isclose(nums[0], 24) == True
            for i, x in enumerate(nums):
                for j, y in enumerate(nums):
                    if i != j:
                        res = []
                        for k, z in enumerate(nums):
                            if k != i and k != j:
                                res.append(z)
                        for k in range(4):
                            if k == ADD:
                                res.append(x + y)
                            elif k == MULTIPLY:
                                res.append(x * y)
                            elif k == SUBTRACT:
                                res.append(x - y)
                            elif k == DIVIDE:
                                res.append(y and x / y)
                            if backtrack(res):
                                return True
                            res.pop()
            return False
        return backtrack(cards)
```