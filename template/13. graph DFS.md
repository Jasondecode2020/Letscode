## template 1: recursion

```python
def fn(g): # g: graph
    def dfs(node):
        res = 0
        # some code
        for neighbor in g[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                ans += dfs(neighbor)
        return res

    visited = {START_NODE}
    return dfs(START_NODE)
```

### template 2: iteration

```python
def fn(g): # g: graph
    stack = [START_NODE]
    visited = {START_NODE}
    res = 0
    while stack:
        node = stack.pop()
        # some code
        for neighbor in g[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                stack.append(neighbor)
    
    return res
```

## template 3: grid

```python
def fn(grid): # grid: 695
    R, C = len(grid), len(grid[0])
    def dfs(r, c):
        if r < 0 or r == R or c < 0 or c == C or grid[r][c] == 0:
            return 0
        grid[r][c] = 0
        return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)
    return max(dfs(r, c) for r in range(R) for c in range(C))
```


### 695. Max Area of Island

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        def dfs(r, c):
            if r < 0 or r == R or c < 0 or c == C or grid[r][c] == 0:
                return 0
            grid[r][c] = 0
            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)
        return max(dfs(r, c) for r in range(R) for c in range(C))
```