## template

```python
def dfs(root):
    if not root:
        return
    res = 0
    # some code
    dfs(root.left)
    dfs(root.right)
    return res
```

## template

```python
def dfs(root):
    stack = [root]
    res = 0
    while stack:
        node = stack.pop()
        # some code
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    return res
```
### Tree Traversal

* `404. Sum of Left Leaves`
* `129. Sum Root to Leaf Numbers`
* `257. Binary Tree Paths`
* `988. Smallest String Starting From Leaf`
* `270. Closest Binary Search Tree Value`
* `272. Closest Binary Search Tree Value II`
* `226. Invert Binary Tree`
* `590. N-ary Tree Postorder Traversal`

### Construct Binary Tree

* `105. Construct Binary Tree from Preorder and Inorder Traversal`
* `106. Construct Binary Tree from Inorder and Postorder Traversal`
* `889. Construct Binary Tree from Preorder and Postorder Traversal`

### Convert to BST

* `108. Convert Sorted Array to Binary Search Tree`
* `109. Convert Sorted List to Binary Search Tree`

### Balanced Binary Tree

* `110. Balanced Binary Tree`

### BST

* `222. Count Complete Tree Nodes`
* `333. Largest BST Subtree`

### 105. Construct Binary Tree from Preorder and Inorder Traversal

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def dfs(pre_l, pre_r, in_l, in_r):
            if pre_l > pre_r:
                return None
            pre_root = pre_l
            in_root = idx[preorder[pre_root]]
            root = TreeNode(preorder[pre_root])
            subtree_l = in_root - in_l
            root.left = dfs(pre_l + 1, pre_l + subtree_l, in_l, in_root - 1)
            root.right = dfs(pre_l + subtree_l + 1, pre_r, in_root + 1, in_r)
            return root

        n = len(preorder)
        idx = {v: i for i, v in enumerate(inorder)}
        return dfs(0, n - 1, 0, n - 1)
```

### 106. Construct Binary Tree from Inorder and Postorder Traversal

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        def dfs(post_l, post_r, in_l, in_r):
            if post_l > post_r:
                return None
            post_root = post_r
            in_root = idx[postorder[post_root]]
            subtree_l = in_root - in_l
            root = TreeNode(postorder[post_root])
            root.left = dfs(post_l, post_l + subtree_l - 1, in_l, in_root - 1)
            root.right = dfs(post_l + subtree_l, post_r - 1, in_root + 1, in_r)
            return root

        n = len(postorder)
        idx = {v: i for i, v in enumerate(inorder)}
        return dfs(0, n - 1, 0, n - 1)
```

### 889. Construct Binary Tree from Preorder and Postorder Traversal

```python
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        def dfs(pre, post):
            if not pre: 
                return None
            root = TreeNode(pre[0])
            if len(pre) == 1: 
                return root

            L = post.index(pre[1]) + 1
            root.left = dfs(pre[1:L+1], post[:L])
            root.right = dfs(pre[L+1:], post[L:-1])
            return root
        return dfs(preorder, postorder)
```

### Question list

* `1448. Count Good Nodes in Binary Tree`
* `1026. Maximum Difference Between Node and Ancestor`
* `2458. Height of Binary Tree After Subtree Removal Queries`

### 1448. Count Good Nodes in Binary Tree

```python
class Solution:
    def goodNodes(self, root: TreeNode, mx=-inf) -> int:
        if not root:
            return 0
        l = self.goodNodes(root.left, max(mx, root.val))
        r = self.goodNodes(root.right, max(mx, root.val))
        return l + r + (root.val >= mx)
```

### 1026. Maximum Difference Between Node and Ancestor

```python
```

### 2458. Height of Binary Tree After Subtree Removal Queries

```python
class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        d = defaultdict(int)
        def dfs_height(node):
            if not node:
                return 0
            h = max(dfs_height(node.left), dfs_height(node.right)) + 1
            d[node] = h 
            return h 
        dfs_height(root)
        
        res = [0] * (len(d) + 1)
        def dfs(node, height, rest_h):
            if not node:
                return 
            height += 1
            res[node.val] = rest_h
            dfs(node.left, height, max(rest_h, height + d[node.right]))
            dfs(node.right, height, max(rest_h, height + d[node.left]))
        dfs(root, -1, 0)

        for i, q in enumerate(queries):
            queries[i] = res[q]
        return queries
```

### Question list: convert to BST

* `108. Convert Sorted Array to Binary Search Tree`
* `109. Convert Sorted List to Binary Search Tree`

### 108. Convert Sorted Array to Binary Search Tree

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        n = len(nums)
        def dfs(l, r):
            if l > r:
                return None
            m = l + (r - l) // 2
            root = TreeNode(nums[m])
            root.left = dfs(l, m - 1)
            root.right = dfs(m + 1, r)
            return root
        return dfs(0, n - 1)
```

### 109. Convert Sorted List to Binary Search Tree

```python
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
            
        n = len(nums)
        def dfs(l, r):
            if l > r:
                return None
            m = l + (r - l) // 2
            root = TreeNode(nums[m])
            root.left = dfs(l, m - 1)
            root.right = dfs(m + 1, r)
            return root
        return dfs(0, n - 1)
```

### 110. Balanced Binary Tree

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def depth(node):
            if not node:
                return 0
            return max(depth(node.left), depth(node.right)) + 1
        
        def isBalanced(node) :
            if not node:
                return True
            if abs(depth(node.left) - depth(node.right)) > 1:
                return False
            return isBalanced(node.left) and isBalanced(node.right)
        return isBalanced(root)
```

- O(n): directly using depth of binary tree

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(node):
            if not node:
                return 0
            left = dfs(node.left)
            if left == -1:
                return -1
            right = dfs(node.right)
            if right == -1 or abs(left - right) > 1:
                return -1
            return max(left, right) + 1
        return dfs(root) != -1
```

### 404. Sum of Left Leaves

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node:
                if node.left and not node.left.left and not node.left.right:
                    self.res += node.left.val
                dfs(node.left)
                dfs(node.right)
        self.res = 0
        dfs(root)
        return self.res
```

### 129. Sum Root to Leaf Numbers

```python
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def check(res):
            for i, a in enumerate(res):
                n = len(a)
                res[i] = sum(a[j] * 10 ** (n - j - 1) for j in range(n))
            return sum(res)
            
        self.res = []
        def dfs(node, path):
            if node:
                if not node.left and not node.right:
                    self.res.append(path + [node.val])
                    return
                dfs(node.left, path + [node.val])
                dfs(node.right, path + [node.val])
        dfs(root, [])
        return check(self.res)
```

### 257. Binary Tree Paths

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def check(res):
            for i, a in enumerate(res):
                a = [str(c) for c in a]
                res[i] = '->'.join(a)
            return res
            
        self.res = []
        def dfs(node, path):
            if node:
                if not node.left and not node.right:
                    self.res.append(path + [node.val])
                    return
                dfs(node.left, path + [node.val])
                dfs(node.right, path + [node.val])
        dfs(root, [])
        return check(self.res)
```

### 988. Smallest String Starting From Leaf

```python
class Solution:
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:
        letters = ascii_lowercase
        def check(res):
            for i, a in enumerate(res):
                res[i] = ''.join([letters[i] for i in a])
            return sorted(res)[0]
            
        self.res = []
        def dfs(node, path):
            if node:
                if not node.left and not node.right:
                    self.res.append([node.val] + path)
                    return
                dfs(node.left, [node.val] + path)
                dfs(node.right, [node.val] + path)
        dfs(root, [])
        return check(self.res)
```

### 270. Closest Binary Search Tree Value

```python
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -> int:
        self.res = inf
        def dfs(node):
            if node:
                if abs(node.val - target) < abs(self.res - target):
                    self.res = node.val
                if abs(node.val - target) == abs(self.res - target):
                    self.res = min(self.res, node.val)
                dfs(node.left)
                dfs(node.right)
        dfs(root)
        return self.res
```

### 272. Closest Binary Search Tree Value II

```python
class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -> List[int]:
        pq = []
        def dfs(node):
            if node:
                heappush(pq, (abs(node.val - target), node.val))
                dfs(node.left)
                dfs(node.right)
        dfs(root)

        res = []
        for i in range(k):
            res.append(heappop(pq)[1])
        return res
```

### 222. Count Complete Tree Nodes

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        def depth(node):
            if not node:
                return 0
            return depth(node.left) + 1
        
        def dfs(node):
            if not node:
                return 0
            l, r = depth(node.left), depth(node.right)
            if l == r:
                print(l)
                return (1 << l) + dfs(node.right)
            else:
                return (1 << r) + dfs(node.left)
        return dfs(root)
```

### 226. Invert Binary Tree

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        return root
```

### 114. Flatten Binary Tree to Linked List

```python
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        def dfs(node, res):
            if node:
                res.append(node)
                dfs(node.left, res)
                dfs(node.right, res)
            return res
        res = dfs(root, [])
        if not res:
            return []
        temp = R = res[0]
        for i in range(1, len(res)):
            R.left = None
            R.right = res[i]
            R = R.right
        return temp
```

### 116. Populating Next Right Pointers in Each Node

```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return None
        q = deque([root])
        res = []
        while q:
            level = []
            for i in range(len(q)):
                node = q.popleft()
                level.append(node)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            for i in range(len(level) - 1):
                level[i].next = level[i + 1]
        return root
```

### 250. Count Univalue Subtrees

```python
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:
        def checkUni(node, s):
            if node:
                s.add(node.val)
                if len(s) == 2:
                    return False
                checkUni(node.left, s)
                checkUni(node.right, s)
            return len(s) == 1

        self.res = 0
        def dfs(node):
            if node:
                if checkUni(node, set()):
                    self.res += 1
                dfs(node.left)
                dfs(node.right)
        dfs(root)
        return self.res
```

### 298. Binary Tree Longest Consecutive Sequence

```python
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        def longest(nums):
            n = len(nums)
            dp = [1] * n
            for i in range(1, n):
                if nums[i] == nums[i - 1] + 1:
                    dp[i] += dp[i - 1]
            return max(dp)
        def check(res):
            ans = 0
            for a in res:
                ans = max(ans, longest(a))
            return ans
            
        self.res = []
        def dfs(node, path):
            if node:
                if not node.left and not node.right:
                    self.res.append(path + [node.val])
                    return
                dfs(node.left, path + [node.val])
                dfs(node.right, path + [node.val])
        dfs(root, [])
        return check(self.res)
```

### 366. Find Leaves of Binary Tree

```python
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -> List[List[int]]:
        def dfs(root):
            if not root:
                return 0
            l, r = dfs(root.left), dfs(root.right)
            depth = max(l, r) + 1
            res[depth].append(root.val)
            return depth

        res = defaultdict(list)
        dfs(root)
        print(res)
        return [v for v in res.values()]
```

### 450. Delete Node in a BST

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left and not root.right:
                return None
            elif not root.left and root.right:
                return root.right
            elif not root.right and root.left:
                return root.left
            temp = root.right
            while temp.left:
                temp = temp.left
            root.val = temp.val
            root.right = self.deleteNode(root.right, root.val)
        return root
```

### design

### 173. Binary Search Tree Iterator

```python
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.q = deque()
        def dfs(node):
            if node:
                dfs(node.left)
                self.q.append(node)
                dfs(node.right)
        dfs(root)

    def next(self) -> int:
        return self.q.popleft().val

    def hasNext(self) -> bool:
        return len(self.q) > 0
```

### stack

### 331. Verify Preorder Serialization of a Binary Tree

```python
class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        for c in preorder.split(','):
            stack.append(c)
            while len(stack) >= 3 and stack[-1] == '#' and stack[-2] == '#' and stack[-3] != '#':
                for i in range(3):
                    stack.pop()
                stack.append('#')
        return stack == ['#']
```

### design

### 341. Flatten Nested List Iterator

```python
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.q = deque()
        def dfs(nestedList):
            for item in nestedList:
                if item.isInteger():
                    self.q.append(item.getInteger())
                else:
                    dfs(item.getList())
        dfs(nestedList)
    
    def next(self) -> int:
        return self.q.popleft()
    
    def hasNext(self) -> bool:
         return len(self.q) > 0
```

### 333. Largest BST Subtree

```python
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -> int:
        def valid(node, l, r):
            if not node:
                return True
            v = node.val
            self.count += 1
            if v <= l or v >= r:
                return False
            return valid(node.left, l, v) and valid(node.right, v, r)

        self.res = 0
        def dfs(node):
            if node:
                self.count = 0
                if valid(node, -inf, inf):
                    self.res = max(self.res, self.count)
                    return
                dfs(node.left)
                dfs(node.right)
        dfs(root)
        return self.res 
```

### 590. N-ary Tree Postorder Traversal

```python
class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        def dfs(node, res):
            if node:
                for child in node.children:
                    dfs(child, res)
                res.append(node.val)
            return res
        return dfs(root, [])
```

### 589. N-ary Tree Preorder Traversal

```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        def dfs(node, res):
            if node:
                res.append(node.val)
                for child in node.children:
                    dfs(child, res)
            return res
        return dfs(root, [])
```

### 559. Maximum Depth of N-ary Tree

```python
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        res = 0
        for child in root.children:
            res = max(res, self.maxDepth(child))
        return res + 1
```

### 653. Two Sum IV - Input is a BST

```python
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        s = set()
        def dfs(node):
            if node:
                res = k - node.val
                if res in s:
                    return True
                s.add(node.val)
                return dfs(node.left) or dfs(node.right)
        return dfs(root) if dfs(root) else False
```

### 938. Range Sum of BST

```python
class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
        self.res = 0
        def dfs(node):
            if node:
                if node.val < low:
                    dfs(node.right)
                elif node.val > high:
                    dfs(node.left)
                else:
                    self.res += node.val
                    dfs(node.left)
                    dfs(node.right)
        dfs(root)
        return self.res
```

### 671. Second Minimum Node In a Binary Tree

```python
class Solution:
    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:
        s = set()
        def dfs(node):
            if node:
                s.add(node.val)
                dfs(node.left)
                dfs(node.right)
        dfs(root)
        res = sorted(list(s))
        return res[1] if len(res) > 1 else -1
```

### 230. Kth Smallest Element in a BST

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        def inorder(root, res):
            if root:
                inorder(root.left, res)
                res.append(root.val)
                inorder(root.right, res)
            return res
        res = inorder(root, [])
        return res[k - 1]
```