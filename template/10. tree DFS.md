## template

```python
def dfs(root):
    if not root:
        return
    res = 0
    # some code
    dfs(root.left)
    dfs(root.right)
    return res
```

## template

```python
def dfs(root):
    stack = [root]
    res = 0
    while stack:
        node = stack.pop()
        # some code
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    return res
```

### Construct Binary Tree

### Question list

* `105. Construct Binary Tree from Preorder and Inorder Traversal`
* `106. Construct Binary Tree from Inorder and Postorder Traversal`
* `889. Construct Binary Tree from Preorder and Postorder Traversal`

### 105. Construct Binary Tree from Preorder and Inorder Traversal

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def dfs(pre_l, pre_r, in_l, in_r):
            if pre_l > pre_r:
                return None
            pre_root = pre_l
            in_root = idx[preorder[pre_root]]
            root = TreeNode(preorder[pre_root])
            subtree_l = in_root - in_l
            root.left = dfs(pre_l + 1, pre_l + subtree_l, in_l, in_root - 1)
            root.right = dfs(pre_l + subtree_l + 1, pre_r, in_root + 1, in_r)
            return root

        n = len(preorder)
        idx = {v: i for i, v in enumerate(inorder)}
        return dfs(0, n - 1, 0, n - 1)
```

### 106. Construct Binary Tree from Inorder and Postorder Traversal

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        def dfs(post_l, post_r, in_l, in_r):
            if post_l > post_r:
                return None
            post_root = post_r
            in_root = idx[postorder[post_root]]
            subtree_l = in_root - in_l
            root = TreeNode(postorder[post_root])
            root.left = dfs(post_l, post_l + subtree_l - 1, in_l, in_root - 1)
            root.right = dfs(post_l + subtree_l, post_r - 1, in_root + 1, in_r)
            return root

        n = len(postorder)
        idx = {v: i for i, v in enumerate(inorder)}
        return dfs(0, n - 1, 0, n - 1)
```

### 889. Construct Binary Tree from Preorder and Postorder Traversal

```python
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        def dfs(pre, post):
            if not pre: 
                return None
            root = TreeNode(pre[0])
            if len(pre) == 1: 
                return root

            L = post.index(pre[1]) + 1
            root.left = dfs(pre[1:L+1], post[:L])
            root.right = dfs(pre[L+1:], post[L:-1])
            return root
        return dfs(preorder, postorder)
```

### Question list

* `1448. Count Good Nodes in Binary Tree`
* `1026. Maximum Difference Between Node and Ancestor`
* `2458. Height of Binary Tree After Subtree Removal Queries`

### 1448. Count Good Nodes in Binary Tree

```python
class Solution:
    def goodNodes(self, root: TreeNode, mx=-inf) -> int:
        if not root:
            return 0
        l = self.goodNodes(root.left, max(mx, root.val))
        r = self.goodNodes(root.right, max(mx, root.val))
        return l + r + (root.val >= mx)
```

### 1026. Maximum Difference Between Node and Ancestor

```python
```

### 2458. Height of Binary Tree After Subtree Removal Queries

```python
class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        d = defaultdict(int)
        def dfs_height(node):
            if not node:
                return 0
            h = max(dfs_height(node.left), dfs_height(node.right)) + 1
            d[node] = h 
            return h 
        dfs_height(root)
        
        res = [0] * (len(d) + 1)
        def dfs(node, height, rest_h):
            if not node:
                return 
            height += 1
            res[node.val] = rest_h
            dfs(node.left, height, max(rest_h, height + d[node.right]))
            dfs(node.right, height, max(rest_h, height + d[node.left]))
        dfs(root, -1, 0)

        for i, q in enumerate(queries):
            queries[i] = res[q]
        return queries
```