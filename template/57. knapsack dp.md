## 0-1 knapsack - template

```python
@cache
def f(v, w, t, i):
    if i == len(v):
        return 0
    elif t < 0:
        return -inf 
    return max(f(v, w, t, i + 1), f(v, w, t - w[i], i + 1) + v[i])
```

### 494. Target Sum

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        @cache
        def f(t, i):
            if i == len(nums):
                return 1 if t == target else 0 
            return f(t - nums[i], i + 1) + f(t + nums[i], i + 1)
        return f(0, 0)
```

### 416. Partition Equal Subset Sum

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        half = sum(nums) // 2
        @cache
        def f(t, i):
            if i == len(nums):
                return True if t == half else False
            return f(t, i + 1) or f(t + nums[i], i + 1)
        return f(0, 0)
```

### 474. Ones and Zeroes

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        @cache
        def f(a, b, i):
            if i == len(strs):
                return 0 if (a <= m and b <= n) else -inf
            if a > m or b > n: # optimize
                return -inf
            ones, zeros = strs[i].count('1'), strs[i].count('0')
            return max(f(a, b, i + 1), f(a + zeros, b + ones, i + 1) + 1)
        res = f(0, 0, 0)
        return res if res != -inf else 0
```

### 1049, 879

## equal to targetdd

### 2915. Length of the Longest Subsequence That Sums to Target

- 0-1 knapsack

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        f = [0] + [-inf] * target # first number to be 0
        for x in nums:
            for i in range(target, x - 1, -1): # start from target to x, can't choose duplicate
                f[i] = max(f[i], f[i - x] + 1) # try to find max
        return f[-1] if f[-1] > 0 else -1
```

### 377. Combination Sum IV

- backtrack not possible

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        self.res, n = 0, len(nums)
        def backtrack(idx, cur):
            if cur == target:
                self.res += 1
                return 
            if cur > target:
                return
            for i in range(0, n):
                backtrack(i, cur + nums[i])
        backtrack(0, 0)
        return self.res
```

- unbounded knapsack

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [1] + [0] * target
        for i in range(1, target + 1):
            for num in nums:
                if num <= i:
                    dp[i] += dp[i - num]
        return dp[-1]
```


