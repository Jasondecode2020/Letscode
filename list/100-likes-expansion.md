# Top 100 likes

- Question list 100 likes

## Hash table (4)

* [1. Two Sum](#1-Two-Sum) 1500
* [49. Group Anagrams](#49-Group-Anagrams) 1600
* [128. Longest Consecutive Sequence](#128-Longest-Consecutive-Sequence) 1700
* [560. Subarray Sum Equals K](#560-Subarray-Sum-Equals-K) 1750

## Two pointers (4)

* [11. Container With Most Water](#11-Container-With-Most-Water) 1600
* [15. 3Sum](#15-3Sum) 1700
* [283. Move Zeroes](#283-Move-Zeroes) 1500
* [42. Trapping Rain Water](#42-Trapping-Rain-Water) 1800

## Sliding window (3)

* [3. Longest Substring Without Repeating Characters](#3-Longest-Substring-Without-Repeating-Characters) 1600
* [438. Find All Anagrams in a String](#438-Find-All-Anagrams-in-a-String) 1700
* [76. Minimum Window Substring](#76-Minimum-Window-Substring)

## Monotonic queue (1)

* [239. Sliding Window Maximum](#239-Sliding-Window-Maximum) 1900

## Sweep line (1)

* [56. Merge Intervals](#56-Merge-Intervals)

## Prefix sum (1)

* [238. Product of Array Except Self](#238-Product-of-Array-Except-Self)

## Array Hash (2)

* [287. Find the Duplicate Number](#287-Find-the-Duplicate-Number)
* [41. First Missing Positive](#41-First-Missing-Positive)

- exercise

* [442. Find All Duplicates in an Array](#442-Find-All-Duplicates-in-an-Array)

## Matrix (4)

* [73. Set Matrix Zeroes](#73-Set-Matrix-Zeroes)
* [54. Spiral Matrix](#54-Spiral-Matrix)
* [48. Rotate Image](#48-Rotate-Image)
* [240. Search a 2D Matrix II](#240-Search-a-2D-Matrix-II)

## Backtracking (8)

* [46. Permutations](#46-Permutations) 1600
* [78. Subsets](#78-Subsets) 1700
* [17. Letter Combinations of a Phone Number](#17-Letter-Combinations-of-a-Phone-Number) 1700
* [39. Combination Sum](#39-Combination-Sum) 1700
* [22. Generate Parentheses](#22-Generate-Parentheses) 1700

* [131. Palindrome Partitioning](#131-Palindrome-Partitioning) 1700
* [79. Word Search](#79-Word-Search) 1800
* [51. N-Queens](#51-N-Queens) 1800

## Graph (3)

* [200. Number of Islands](#200-Number-of-Islands) 1500
* [994. Rotting Oranges](#994-Rotting-Oranges) 1432
* [207. Course Schedule](#207-Course-Schedule) 1700

## Trie (1)

* [208. Implement Trie (Prefix Tree)](#208-Implement-Trie) 1700

## Heap (3)

* [215. Kth Largest Element in an Array](#215-Kth-Largest-Element-in-an-Array) 1500
* [347. Top K Frequent Elements](#347-Top-K-Frequent-Elements) 1600
* [295. Find Median from Data Stream](#295-Find-Median-from-Data-Stream) 1700

## stack (4)

* [20. Valid Parentheses](#20-Valid-Parentheses) 1300
* [155. Min Stack](#155-Min-Stack) 1500
* [394. Decode String](#394-Decode-String) 1700
* [32. Longest Valid Parentheses](#32-Longest-Valid-Parentheses)

## Monotonic stack (2)

* [739. Daily Temperatures](#739-Daily-Temperatures) 1700
* [84. Largest Rectangle in Histogram](#84-Largest-Rectangle-in-Histogram) 1900

## Linked list (14)

* [160. Intersection of Two Linked Lists](#160-Intersection-of-Two-Linked-Lists)
* [206. Reverse Linked List](#206-Reverse-Linked-List)
* [234. Palindrome Linked List](#234-Palindrome-Linked-List)
* [141. Linked List Cycle](#141-Linked-List-Cycle)
* [142. Linked List Cycle II](#142-Linked-List-Cycle-II)

* [21. Merge Two Sorted Lists](#21-Merge-Two-Sorted-Lists)
* [2. Add Two Numbers](#2-Add-Two-Numbers)
* [19. Remove Nth Node From End of List](#19-Remove-Nth-Node-From-End-of-List)
* [24. Swap Nodes in Pairs](#24-Swap-Nodes-in-Pairs)
* [25. Reverse Nodes in k-Group](#25-Reverse-Nodes-in-k-Group)

* [23. Merge k Sorted Lists](#23-Merge-k-Sorted-Lists)
* [138. Copy List with Random Pointer](#138-Copy-List-with-Random-Pointer)
* [148. Sort List](#148-Sort-List)
* [146. LRU Cache](#146-LRU-Cache)

## Tree (15)

* [94. Binary Tree Inorder Traversal](#94-Binary-Tree-Inorder-Traversal)
* [104. Maximum Depth of Binary Tree](#104-Maximum-Depth-of-Binary-Tree)
* [226. Invert Binary Tree](#226-Invert-Binary-Tree)
* [101. Symmetric Tree](#101-Symmetric-Tree)
* [543. Diameter of Binary Tree](#543-Diameter-of-Binary-Tree)

* [102. Binary Tree Level Order Traversal](#102-Binary-Tree-Level-Order-Traversal)
* [108. Convert Sorted Array to Binary Search Tree](#108-Convert-Sorted-Array-to-Binary-Search-Tree)
* [98. Validate Binary Search Tree](#98-Validate-Binary-Search-Tree)
* [230. Kth Smallest Element in a BST](#230-Kth-Smallest-Element-in-a-BST)
* [199. Binary Tree Right Side View](#199-Binary-Tree-Right-Side-View)

* [105. Construct Binary Tree from Preorder and Inorder Traversal](#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal)
* [437. Path Sum III](#437-Path-Sum-III)
* [236. Lowest Common Ancestor of a Binary Tree](#236-Lowest-Common-Ancestor-of-a-Binary-Tree)
* [114. Flatten Binary Tree to Linked List](#114-Flatten-Binary-Tree-to-Linked-List)
* [124. Binary Tree Maximum Path Sum](#124-Binary-Tree-Maximum-Path-Sum)

## Binary Search (6)

* [35. Search Insert Position](#35-Search-Insert-Position)
* [74. Search a 2D Matrix](#74-Search-a-2D-Matrix)
* [34. Find First and Last Position of Element in Sorted Array](#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array)
* [33. Search in Rotated Sorted Array](#33-Search-in-Rotated-Sorted-Array)
* [153. Find Minimum in Rotated Sorted Array](#153-Find-Minimum-in-Rotated-Sorted-Array)
* [4. Median of Two Sorted Arrays](#4-Median-of-Two-Sorted-Arrays)

## DP

### DP 1D (5)

* [70. Climbing Stairs](#70-Climbing-Stairs)
* [118. Pascal's Triangle](#118-Pascal's-Triangle)
* [53. Maximum Subarray](#53-Maximum-Subarray)
* [198. House Robber](#198-House-Robber)
* [152. Maximum Product Subarray](#152-Maximum-Product-Subarray)

### DP knapsack

* [322. Coin Change](#322-Coin-Change)
* [279. Perfect Squares](#279-Perfect-Squares)
* [53. Maximum Subarray](#53-Maximum-Subarray)

### Dp 2D (6)

* [62. Unique Paths](#62-Unique-Paths)
* [64. Minimum Path Sum](#64-Minimum-Path-Sum)
* [1143. Longest Common Subsequence](#1143-Longest-Common-Subsequence)
* [5. Longest Palindromic Substring](#5-Longest-Palindromic-Substring)
* [72. Edit Distance](#72-Edit-Distance)
* [139. Word Break](#139-Word-Break)

### exercise (2)

* [132. Palindrome Partitioning II](#132-Palindrome-Partitioning-II)
* [3144. Minimum Substring Partition of Equal Character Frequency](#3144-minimum-substring-partition-of-equal-character-frequency)

## greedy (4)

* [121. Best Time to Buy and Sell Stock](#121-Best-Time-to-Buy-and-Sell-Stock)
* [55. Jump Game](#55-Jump-Game)
* [45. Jump Game II](#45-Jump-Game-II)
* [763. Partition Labels](#763-Partition-Labels)

## Tricks (5)

* [136. Single Number](#136-Single-Number)
* [189. Rotate Array](#189-Rotate-Array)
* [169. Majority Element](#169-Majority-Element)
* [31. Next Permutation](#31-Next-Permutation)
* [75. Sort Colors](#75-Sort-Colors)

# #########################################################################################################
# Question tags                                                                                           #
# #########################################################################################################

## Hash table (4)

* [1. Two Sum](#1-Two-Sum) 1500
* [49. Group Anagrams](#49-Group-Anagrams) 1600
* [128. Longest Consecutive Sequence](#128-Longest-Consecutive-Sequence) 1700
* [560. Subarray Sum Equals K](#560-Subarray-Sum-Equals-K) 1750

### 1. Two Sum

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i, v in enumerate(nums):
            res = target - v
            if res in d:
                return [d[res], i]
            d[v] = i
```

### 49. Group Anagrams

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = defaultdict(list)
        for word in strs:
            d[''.join(sorted(list(word)))].append(word)
        return list(d.values())
```

### 128. Longest Consecutive Sequence

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums = set(nums)
        res = 0
        for n in nums:
            if n - 1 not in nums:
                j = n
                while j in nums:
                    j += 1
                res = max(res, j - n)
        return res
```

### 560. Subarray Sum Equals K

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # [1,1,1], k = 2
        # [0, 1, 2, 3] n - x = k => n - k = x
        d, res = Counter(), 0
        pre = list(accumulate(nums, initial = 0))
        for n in pre:
            ans = n - k
            if ans in d:
                res += d[ans]
            d[n] += 1
        return res
```

## Two pointers (4)

* [11. Container With Most Water](#11-Container-With-Most-Water) 1600
* [15. 3Sum](#15-3Sum) 1700
* [283. Move Zeroes](#283-Move-Zeroes) 1500
* [42. Trapping Rain Water](#42-Trapping-Rain-Water) 1800

### 11. Container With Most Water

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        res = 0
        while l < r:
            res = max(res, min(height[l], height[r]) * (r - l))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return res
```

### 15. 3Sum

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        s = set()
        n = len(nums)
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, n - 1
            while l < r:
                three = nums[i] + nums[l] + nums[r]
                if three == 0:
                    s.add((nums[i], nums[l], nums[r]))
                    l += 1
                    r -= 1
                elif three > 0:
                    r -= 1
                else:
                    l += 1
        return list(s)
```

### 283. Move Zeroes

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l = 0
        for r, n in enumerate(nums):
            if n:
                nums[l] = n 
                l += 1
        for i in range(l, len(nums)):
            nums[i] = 0
```

### 42. Trapping Rain Water

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l = 0
        for r, n in enumerate(nums):
            if n:
                nums[l] = n 
                l += 1
        for i in range(l, len(nums)):
            nums[i] = 0
```

## Sliding window (3)

* [3. Longest Substring Without Repeating Characters](#3-Longest-Substring-Without-Repeating-Characters) 1600
* [438. Find All Anagrams in a String](#438-Find-All-Anagrams-in-a-String) 1700
* [76. Minimum Window Substring](#76-Minimum-Window-Substring) 1800

### 3. Longest Substring Without Repeating Characters

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l, res = 0, 0
        d = defaultdict(int)
        for r, c in enumerate(s):
            d[c] += 1
            while d[c] > 1:
                d[s[l]] -= 1
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 438. Find All Anagrams in a String

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        countP = Counter(p)
        res, l = [], 0
        d = Counter()
        P = len(p)
        for r, c in enumerate(s):
            d[c] += 1
            if r - l + 1 == P:
                if d == countP:
                    res.append(l)
                d[s[l]] -= 1
                l += 1
        return res 
```

### 76. Minimum Window Substring

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        d, d_t = Counter(), Counter(t)
        res, l = s + '#', 0
        have, need = 0, len(d_t)
        for r, c in enumerate(s):
            d[c] += 1
            if d[c] == d_t[c]:
                have += 1
            while have == need:
                res = min(res, s[l: r + 1], key = len)
                d[s[l]] -= 1
                if s[l] in d_t and d[s[l]] < d_t[s[l]]:
                    have -= 1
                l += 1
        return res if res != s + '#' else ''
```

## monotonic queue (1)

* [239. Sliding Window Maximum](#239-Sliding-Window-Maximum) 1900

### 239. Sliding Window Maximum

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res, q = [], deque()
        for r, n in enumerate(nums):
            while q and n > nums[q[-1]]:
                q.pop()
            q.append(r)
            if r - q[0] + 1 > k:
                q.popleft()
            if r >= k - 1:
                res.append(nums[q[0]])
        return res
```

## sweep line

* [56. Merge Intervals](#56-Merge-Intervals)

### 56. Merge Intervals

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        events = []
        for s, e in intervals:
            events.append((s, -1))
            events.append((e, 1))
        events.sort()

        res = []
        start = inf
        count = 0
        for t, sign in events:
            if sign == -1:
                count += 1
                start = min(start, t)
            else:
                count -= 1
                if count == 0:
                    res.append([start, t])
                    start = inf
        return res
```

## Prefix sum

* [238. Product of Array Except Self](#238-Product-of-Array-Except-Self)

### 238. Product of Array Except Self

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res, tmp = [1] * n, 1
        for i in range(1, n):
            res[i] = res[i - 1] * nums[i - 1]
        for i in range(n - 2, -1, -1):
            tmp *= nums[i + 1]
            res[i] *= tmp
        return res
```

## Array Hash (2)

* [287. Find the Duplicate Number](#287-Find-the-Duplicate-Number)
* [41. First Missing Positive](#41-First-Missing-Positive)

### 287. Find the Duplicate Number

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        for i, n in enumerate(nums):
            n = abs(n)
            if nums[n - 1] == -abs(nums[n - 1]):
                return n 
            else:
                nums[n - 1] = -abs(nums[n - 1])
```

### 41. First Missing Positive

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        # set inf 
        for i in range(n):
            if nums[i] <= 0 or nums[i] > n:
                nums[i] = inf 
        # set negative
        for i in range(n):
            if abs(nums[i]) != inf:
                v = abs(nums[i])
                nums[v - 1] = -abs(nums[v - 1])
        # find out
        for i in range(n):
            if nums[i] > 0:
                return i + 1
        return n + 1
```

### 442 All Duplicates in an Array

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for i, n in enumerate(nums):
            n = abs(n)
            if nums[n - 1] == -abs(nums[n - 1]):
                res.append(n)
            else:
                nums[n - 1] = -abs(nums[n - 1])
        return res 
```

## Matrix (4)

* [73. Set Matrix Zeroes](#73-Set-Matrix-Zeroes)
* [54. Spiral Matrix](#54-Spiral-Matrix)
* [48. Rotate Image](#48-Rotate-Image)
* [240. Search a 2D Matrix II](#240-Search-a-2D-Matrix-II)

### 73. Set Matrix Zeroes

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        R, C = len(matrix), len(matrix[0])
        for r in range(1, R):
            for c in range(1, C):
                if matrix[r][c] == 0:
                    matrix[0][c] = -matrix[0][c]
                    matrix[r][0] = -matrix[r][0]

        for r in range(1, R):
            for c in range(1, C):
                if matrix[r][0] < 0 or matrix[0][c] < 0:
                    matrix[r][c] = 0

        for r in range(R):
            if matrix[r][0] == 0:
                for r in range(R):
                    matrix[r][0] = 0
                break
        for c in range(C):
            if matrix[0][c] == 0:
                for c in range(C):
                    matrix[0][c] = 0
                break
        for r in range(R):
            for c in range(C):
                matrix[r][c] = abs(matrix[r][c])
```

### 54. Spiral Matrix

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        R, C = len(matrix), len(matrix[0])
        top, bottom, left, right = 0, R - 1, 0, C - 1
        res = []
        while top <= bottom and left <= right:
            # top
            for c in range(left, right + 1):
                res.append(matrix[top][c])
            top += 1
            # right
            for r in range(top, bottom + 1):
                res.append(matrix[r][right])
            right -= 1
            if left > right or top > bottom:
                continue
            # bottom
            for c in range(right, left - 1, -1):
                res.append(matrix[bottom][c])
            bottom -= 1
            # left
            for r in range(bottom, top - 1, -1):
                res.append(matrix[r][left])
            left += 1
        return res 
```

### 48. Rotate Image

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        matrix.reverse()
        R, C = len(matrix), len(matrix[0])
        for r in range(R):
            for c in range(r):
                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]
        return matrix
```

### 240. Search a 2D Matrix II

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        for m in matrix:
            i = bisect_left(m, target)
            if i < len(m) and m[i] == target:
                return True
        return False
```

## Backtracking (8)

* [46. Permutations](#46-Permutations) 1600
* [78. Subsets](#78-Subsets) 1700
* [17. Letter Combinations of a Phone Number](#17-Letter-Combinations-of-a-Phone-Number) 1700
* [39. Combination Sum](#39-Combination-Sum) 1700
* [22. Generate Parentheses](#22-Generate-Parentheses) 1700
* [131. Palindrome Partitioning](#131-Palindrome-Partitioning) 1700
* [79. Word Search](#79-Word-Search) 1800
* [51. N-Queens](#51-N-Queens) 1800

### 46. Permutations

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, path):
            if not nums:
                res.append(path)
                return 
            for i in range(len(nums)):
                backtrack(nums[ :i] + nums[i + 1:], path + [nums[i]])
        res = []
        backtrack(nums, [])
        return res
```

### 78. Subsets

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        def backtrack(i, ans):
            if i == n:
                res.append(ans)
                return 
            backtrack(i + 1, ans + [nums[i]])
            backtrack(i + 1, ans)
        res, n = [], len(nums)
        backtrack(0, [])
        return res 
```

### 17. Letter Combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        
        def backtrack(i, cur):
            if len(cur) == n:
                res.append(cur)
                return
            for c in d[digits[i]]:
                backtrack(i + 1, cur + c)
        res, n = [], len(digits)
        backtrack(0, '')
        return res if digits else []
```

### 39. Combination Sum

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtrack(idx, ans, total):
            if total == target:
                res.append(ans)
                return 
            if total > target:
                return 
            for i in range(idx, n):
                backtrack(i, ans + [candidates[i]], total + candidates[i])
        res, n = [], len(candidates)
        backtrack(0, [], 0)
        return res
```

### 22. Generate Parentheses

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def backtrack(open, close, ans):
            if open == close == n:
                res.append(ans)
                return 
            if open < n:
                backtrack(open + 1, close, ans + '(')
            if close < open:
                backtrack(open, close + 1, ans + ')')
        backtrack(0, 0, '')
        return res
```

### 131. Palindrome Partitioning

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def valid(s):
            return s == s[::-1]
        def backtrack(i, ans):
            if ans and not valid(ans[-1]):
                return 
            if i == n:
                res.append(ans)
                return 
            for j in range(i, n):
                backtrack(j + 1, ans + [s[i: j + 1]])

        n = len(s)
        res = []
        backtrack(0, [])
        return res 
```

### 79. Word Search

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        R, C, n, visited = len(board), len(board[0]), len(word), set()
        s = ''.join([''.join(item) for item in board])
        if any(s.count(c) < word.count(c) for c in word):
            return False
        def dfs(i, r, c):
            if i == len(word):
                return True
            if 0 <= r < R and 0 <= c < C and (r, c) not in visited and board[r][c] == word[i]:
                visited.add((r, c))
                res = dfs(i + 1, r + 1, c) or dfs(i + 1, r, c + 1) or dfs(i + 1, r - 1, c) or dfs(i + 1, r, c - 1)
                visited.remove((r, c))
                return res 
            return False

        for r in range(R):
            for c in range(C):
                if board[r][c] == word[0] and dfs(0, r, c):
                    return True
        return False
```

### 51. N-Queens

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col, posDiag, negDiag = set(), set(), set()
        res, board = [], [['.'] * n for i in range(n)]
        def backtrack(r):
            if r == n:
                res.append([''.join(row) for row in board])
                return
            for c in range(n):
                if c not in col and (r + c) not in posDiag and (r - c) not in negDiag:
                    col.add(c)
                    posDiag.add(r + c)
                    negDiag.add(r - c)
                    board[r][c] = 'Q'
                    backtrack(r + 1)
                    col.remove(c)
                    posDiag.remove(r + c)
                    negDiag.remove(r - c)
                    board[r][c] = '.'
        backtrack(0)
        return res
```

## Graph

* [200. Number of Islands](#200-Number-of-Islands) 1500
* [994. Rotting Oranges](#994-Rotting-Oranges) 1432
* [207. Course Schedule](#207-Course-Schedule) 1700
* [208. Implement Trie (Prefix Tree)](#208-Implement-Trie) 1700

### 200. Number of Islands

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def valid(s):
            return s == s[::-1]
        def backtrack(i, ans):
            if ans and not valid(ans[-1]):
                return 
            if i == n:
                res.append(ans)
                return 
            for j in range(i, n):
                backtrack(j + 1, ans + [s[i: j + 1]])

        n = len(s)
        res = []
        backtrack(0, [])
        return res 
```

### 994. Rotting Oranges

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def valid(s):
            return s == s[::-1]
        def backtrack(i, ans):
            if ans and not valid(ans[-1]):
                return 
            if i == n:
                res.append(ans)
                return 
            for j in range(i, n):
                backtrack(j + 1, ans + [s[i: j + 1]])

        n = len(s)
        res = []
        backtrack(0, [])
        return res 
```

### 207. Course Schedule

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegree = [0] * numCourses
        g = defaultdict(list)
        for u, v in prerequisites:
            indegree[u] += 1
            g[v].append(u)

        q = deque([i for i, v in enumerate(indegree) if v == 0])
        res = 0
        while q:
            node = q.popleft()
            res += 1
            for nei in g[node]:
                indegree[nei] -= 1
                if indegree[nei] == 0:
                    q.append(nei)
        return res == numCourses
```

## Trie (1)

* [208. Implement Trie (Prefix Tree)](#208-Implement-Trie) 1700

### 208. Implement Trie

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def valid(s):
            return s == s[::-1]
        def backtrack(i, ans):
            if ans and not valid(ans[-1]):
                return 
            if i == n:
                res.append(ans)
                return 
            for j in range(i, n):
                backtrack(j + 1, ans + [s[i: j + 1]])

        n = len(s)
        res = []
        backtrack(0, [])
        return res 
```

## Heap (3)

* [215. Kth Largest Element in an Array](#215-Kth-Largest-Element-in-an-Array) 1500
* [347. Top K Frequent Elements](#347-Top-K-Frequent-Elements) 1600
* [295. Find Median from Data Stream](#295-Find-Median-from-Data-Stream) 1700

### 215. Kth Largest Element in an Array

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        pq = []
        for n in nums:
            heappush(pq, -n)
        
        for i in range(k):
            res = -heappop(pq)
        return res
```

### 347. Top K Frequent Elements

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        pq = []
        for key, v in Counter(nums).items():
            heappush(pq, (-v, key))
        res = []
        for i in range(k):
            v, key = heappop(pq)
            res.append(key)
        return res
```

### 295. Find Median from Data Stream

```python
class MedianFinder:

    def __init__(self):
        self.a = []
        self.b = []

    def addNum(self, num: int) -> None:
        if len(self.a) != len(self.b):
            heappush(self.b, -heappushpop(self.a, num))
        else:
            heappush(self.a, -heappushpop(self.b, -num))

    def findMedian(self) -> float:
        return self.a[0] if len(self.a) != len(self.b) else (self.a[0] - self.b[0]) / 2.0
```

## stack (4)

* [20. Valid Parentheses](#20-Valid-Parentheses) 1300
* [155. Min Stack](#155-Min-Stack) 1500
* [394. Decode String](#394-Decode-String) 1700
* [32. Longest Valid Parentheses](#32-Longest-Valid-Parentheses) 2500

### 20. Valid Parentheses

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if stack and ((stack[-1] == '(' and c == ')') or (stack[-1] == '[' and c == ']') or (stack[-1] == '{' and c == '}')):
                stack.pop()
            else:
                stack.append(c)
        return not stack
```

### 155. Min Stack

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.mn = [inf]

    def push(self, val: int) -> None:
        self.stack.append(val)
        self.mn.append(min(self.mn[-1], val))

    def pop(self) -> None:
        self.stack.pop()
        self.mn.pop()
    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.mn[-1]
```

### 394. Decode String

```python
class Solution:
    def decodeString(self, s: str) -> str:
        stack = []
        for c in s:
            if c != ']':
                stack.append(c)
            else:
                s = ''
                while stack[-1].isalpha():
                    c = stack.pop()
                    s = c + s
                stack.pop()
                d = ''
                while stack and stack[-1].isdigit():
                    c = stack.pop()
                    d = c + d 
                stack.append(s * int(d))
        return ''.join(stack)
```

### 32. Longest Valid Parentheses

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack, res = [-1], 0
        for i, c in enumerate(s):
            if c == '(':
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    res = max(res, i - stack[-1])
        return res 
```

## Monotonic stack (2)

* [739. Daily Temperatures](#739-Daily-Temperatures) 1700
* [84. Largest Rectangle in Histogram](#84-Largest-Rectangle-in-Histogram) 1900

### 739. Daily Temperatures

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res, stack = [0] * n, []
        for i, t in enumerate(temperatures):
            while stack and t > temperatures[stack[-1]]:
                j = stack.pop()
                res[j] = i - j
            stack.append(i)
        return res
```

### 84. Largest Rectangle in Histogram

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        res, stack, heights = 0, [-1], heights + [0]
        for i, h in enumerate(heights):
            while len(stack) > 1 and h < heights[stack[-1]]:
                j = stack.pop()
                res = max(res, (i - 1 - stack[-1]) * heights[j])
            stack.append(i)
        return res
```

## Linked list (14)

* [160. Intersection of Two Linked Lists](#160-Intersection-of-Two-Linked-Lists)
* [206. Reverse Linked List](#206-Reverse-Linked-List)
* [234. Palindrome Linked List](#234-Palindrome-Linked-List)
* [141. Linked List Cycle](#141-Linked-List-Cycle)
* [142. Linked List Cycle II](#142-Linked-List-Cycle-II)

* [21. Merge Two Sorted Lists](#21-Merge-Two-Sorted-Lists)
* [2. Add Two Numbers](#2-Add-Two-Numbers)
* [19. Remove Nth Node From End of List](#19-Remove-Nth-Node-From-End-of-List)
* [24. Swap Nodes in Pairs](#24-Swap-Nodes-in-Pairs)
* [25. Reverse Nodes in k-Group](#25-Reverse-Nodes-in-k-Group)

* [23. Merge k Sorted Lists](#23-Merge-k-Sorted-Lists)
* [138. Copy List with Random Pointer](#138-Copy-List-with-Random-Pointer)
* [148. Sort List](#148-Sort-List)
* [146. LRU Cache](#146-LRU-Cache)

### 160. Intersection of Two Linked Lists

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        h1, h2 = headA, headB
        while h1 is not h2:
            h1 = h1.next if h1 else headB
            h2 = h2.next if h2 else headA
        return h1
```

### 206. Reverse Linked List

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev, cur = None, head
        while cur:
            nxt = cur.next 
            cur.next = prev 
            prev, cur = cur, nxt 
        return prev
```

### 234. Palindrome Linked List

```python
class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        res = []
        while head:
            res.append(head.val)
            head = head.next 
        return res == res[::-1]

class Solution:
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        total = 0
        p = head 
        while p:
            total += 1
            p = p.next 

        p = dummy = ListNode()
        p.next = head 
        slow, fast = dummy, dummy 
        while fast and fast.next:
            slow = slow.next 
            fast = fast.next.next 
        if total % 2 == 0:
            l2 = slow.next 
        else:
            l2 = slow 
        def reverseLinkedList(prev, cur):
            while cur:
                nxt = cur.next 
                cur.next = prev 
                prev, cur = cur, nxt 
            return prev 

        p2 = reverseLinkedList(None, l2)
        while head and p2:
            if head.val != p2.val:
                return False
            head = head.next 
            p2 = p2.next
        return True
```

### 141. Linked List Cycle

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow, fast = head, head 
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next 
            if slow == fast:
                return True
        return False
```

### 142. Linked List Cycle II

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow, fast = head, head 
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next 
            if slow == fast:
                while slow != head:
                    head = head.next 
                    slow = slow.next 
                return head
        return None
```

### 21. Merge Two Sorted Lists

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        while list1 and list2:
            if list1.val > list2.val:
                p.next = ListNode(list2.val)
                list2 = list2.next 
            else:
                p.next = ListNode(list1.val)
                list1 = list1.next 
            p = p.next 
        p.next = list1 if list1 else list2
        return dummy.next 
```

### 2. Add Two Numbers

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        carry = 0
        while l1 or l2:
            val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            p.next = ListNode(val % 10)
            if l1: l1 = l1.next
            if l2: l2 = l2.next
            p = p.next
            carry = val // 10
        if carry: p.next = ListNode(carry)
        return dummy.next
```

### 19. Remove Nth Node From End of List

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head 
        slow = fast = dummy
        for i in range(n + 1):
            fast = fast.next 
        while fast:
            fast = fast.next
            slow = slow.next 
        slow.next = slow.next.next 
        return dummy.next 
```

### 24. Swap Nodes in Pairs

```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # prev -> 1 -> 2 -> 3 -> 4
        dummy = ListNode()
        dummy.next = head
        prev, cur = dummy, head

        total = 0
        while head:
            total += 1
            head = head.next 

        def swapOnePair():
            nxt = cur.next
            cur.next = nxt.next 
            nxt.next = prev.next
            prev.next = nxt 

        for i in range(total // 2):
            swapOnePair()
            prev, cur = cur, cur.next 
        return dummy.next
```

### 25. Reverse Nodes in k-Group

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        dummy = ListNode()
        dummy.next = head
        prev, cur = dummy, head

        total = 0
        while head:
            total += 1
            head = head.next 

        def swapOnePair():
            nxt = cur.next
            cur.next = nxt.next 
            nxt.next = prev.next
            prev.next = nxt 

        for i in range(total // k):
            for j in range(k - 1):
                swapOnePair()
            prev, cur = cur, cur.next 
        return dummy.next
```

### 23. Merge k Sorted Lists

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        p = dummy = ListNode()
        pq = []
        for l in lists:
            while l:
                heappush(pq, l.val)
                l = l.next 
        while pq:
            val = heappop(pq)
            p.next = ListNode(val)
            p = p.next
        return dummy.next
```

### 138. Copy List with Random Pointer

```python
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        d = {}
        p = head 
        while p:
            d[p] = Node(p.val)
            p = p.next 

        p = head 
        while p:
            d[p].next = d.get(p.next)
            d[p].random = d.get(p.random)
            p = p.next 
        return d[head] if head else None
```

### 148. Sort List

```python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        res = []
        while head:
            res.append(head.val)
            head = head.next 
        res.sort()
        dummy = p = ListNode()
        for n in res:
            p.next = ListNode(n)
            p = p.next 
        return dummy.next 
```

### 146. LRU Cache

```python
class ListNode:
    def __init__(self, key = 0, value = 0):
        self.key = key
        self.value = value

class LRUCache:

    def __init__(self, capacity: int):
        self.cache = {}
        self.head = self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            node = ListNode(key, value)
            self.cache[key] = node
            self.addToHead(node)
            self.capacity -= 1
            if self.capacity < 0:
                removed = self.removeTail(self.tail.prev)
                self.cache.pop(removed.key)
        else:
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def removeTail(self, node):
        self.removeNode(node)
        return node
```

## Tree (15)

* [94. Binary Tree Inorder Traversal](#94-Binary-Tree-Inorder-Traversal)
* [104. Maximum Depth of Binary Tree](#104-Maximum-Depth-of-Binary-Tree)
* [226. Invert Binary Tree](#226-Invert-Binary-Tree)
* [101. Symmetric Tree](#101-Symmetric-Tree)
* [543. Diameter of Binary Tree](#543-Diameter-of-Binary-Tree)

* [102. Binary Tree Level Order Traversal](#102-Binary-Tree-Level-Order-Traversal)
* [108. Convert Sorted Array to Binary Search Tree](#108-Convert-Sorted-Array-to-Binary-Search-Tree)
* [98. Validate Binary Search Tree](#98-Validate-Binary-Search-Tree)
* [230. Kth Smallest Element in a BST](#230-Kth-Smallest-Element-in-a-BST)
* [199. Binary Tree Right Side View](#199-Binary-Tree-Right-Side-View)

* [105. Construct Binary Tree from Preorder and Inorder Traversal](#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal)
* [437. Path Sum III](#437-Path-Sum-III)
* [236. Lowest Common Ancestor of a Binary Tree](#236-Lowest-Common-Ancestor-of-a-Binary-Tree)
* [114. Flatten Binary Tree to Linked List](#114-Flatten-Binary-Tree-to-Linked-List)
* [124. Binary Tree Maximum Path Sum](#124-Binary-Tree-Maximum-Path-Sum)

### 94. Binary Tree Inorder Traversal

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node, res):
            if node:
                dfs(node.left, res)
                res.append(node.val)
                dfs(node.right, res)
            return res 
        return dfs(root, [])
```

### 104. Maximum Depth of Binary Tree

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if not node:
                return 0
            return max(dfs(node.left), dfs(node.right)) + 1
        return dfs(root)
```

### 226. Invert Binary Tree

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        return root
```

### 101. Symmetric Tree

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
      def symmetric(p, q):
        if not p and not q:
          return True
        if p and not q or q and not p or p.val != q.val:
          return False
        return symmetric(p.left, q.right) and symmetric(p.right, q.left)
      return symmetric(root.left, root.right)
```

### 543. Diameter of Binary Tree

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.res = 0
        def dfs(node):
            if not node:
                return 0
            l, r = dfs(node.left), dfs(node.right)
            self.res = max(self.res, l + r)
            return max(l, r) + 1
        dfs(root)
        return self.res
```


### 102. Binary Tree Level Order Traversal

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        q = deque([root])
        res = []
        while q:
            a = []
            for i in range(len(q)):
                node = q.popleft()
                a.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            res.append(a)
        return res
```

### 108. Convert Sorted Array to Binary Search Tree

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def dfs(l, r):
            if l > r:
                return None
            m = l + (r - l) // 2
            root = TreeNode(nums[m])
            root.left = dfs(l, m - 1)
            root.right = dfs(m + 1, r)
            return root
        return dfs(0, len(nums) - 1)
```

#### 109. Convert Sorted List to Binary Search Tree

```python
class Solution:
    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
            
        def dfs(l, r):
            if l > r:
                return None
            m = l + (r - l) // 2
            root = TreeNode(nums[m])
            root.left = dfs(l, m - 1)
            root.right = dfs(m + 1, r)
            return root
        return dfs(0, len(nums) - 1)
```

### 98. Validate Binary Search Tree

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode], l = -inf, r = inf) -> bool:
        if not root:
            return True
        v = root.val 
        if v <= l or v >= r:
            return False
        return self.isValidBST(root.left, l, v) and self.isValidBST(root.right, v, r)
```

### 230. Kth Smallest Element in a BST

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        def inorder(root, res):
            if root:
                inorder(root.left, res)
                res.append(root.val)
                inorder(root.right, res)
            return res
        res = inorder(root, [])
        return res[k - 1]
```

### 199. Binary Tree Right Side View

```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        res, q = [], deque([root])
        while q:
            n = len(q)
            for i in range(n):
                node = q.popleft()
                if i == n - 1:
                    res.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        return res
```

### 105. Construct Binary Tree from Preorder and Inorder Traversal

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def dfs(preorder, inorder):
            if not preorder:
                return None 
            node = TreeNode(preorder[0])
            m = inorder.index(preorder[0])
            node.left = dfs(preorder[1:m+1], inorder[:m])
            node.right = dfs(preorder[m+1:], inorder[m+1:])
            return node 
        return dfs(preorder, inorder)
```

### 437. Path Sum III

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        def dfs(node, presum):
            if node: 
                if node.val + presum == targetSum:
                    self.res += 1
                dfs(node.left, presum + node.val)
                dfs(node.right, presum + node.val)
        
        self.res = 0
        def preorder(node):
            if node:
                dfs(node, 0)
                preorder(node.left)
                preorder(node.right)
        preorder(root)
        return self.res
# O(n)
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        def dfs(node, presum):
            if not node:
                return 
            curr =  node.val + presum
            self.res += prefix[curr - targetSum]
            prefix[curr] += 1
            dfs(node.left, presum + node.val)
            dfs(node.right, presum + node.val)
            prefix[curr] -= 1
        
        self.res = 0
        prefix = defaultdict(int)
        prefix[0] = 1
        dfs(root, 0)
        return self.res
```

### 236. Lowest Common Ancestor of a Binary Tree

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def dfs(node):
            if not node or node in [p, q]:
                return node 
            left, right = dfs(node.left), dfs(node.right)
            if left and right:
                return node 
            elif left:
                return left 
            else:
                return right 
        return dfs(root)
```

### 114. Flatten Binary Tree to Linked List

```python
class Solution:
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        def dfs(node, p):
            if node:
                node.left = None
                dfs(node.left, p)
                dfs(node.right, p)
        p = temp = root
        dfs(root, p)
        return temp
```

### 124. Binary Tree Maximum Path Sum

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if not node:
                return 0
            l, r = max(dfs(node.left), 0), max(dfs(node.right), 0)
            self.res = max(self.res, node.val + l + r)
            return node.val + max(l, r)
        self.res = -inf
        dfs(root)
        return self.res 
```

## Binary Search (6)

* [35. Search Insert Position](#35-Search-Insert-Position)
* [74. Search a 2D Matrix](#74-Search-a-2D-Matrix)
* [34. Find First and Last Position of Element in Sorted Array](#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array)
* [33. Search in Rotated Sorted Array](#33-Search-in-Rotated-Sorted-Array)
* [153. Find Minimum in Rotated Sorted Array](#153-Find-Minimum-in-Rotated-Sorted-Array)
* [4. Median of Two Sorted Arrays](#4-Median-of-Two-Sorted-Arrays)

## Binary Search practice (1)

* [81. Search in Rotated Sorted Array II](#81-Search-in-Rotated-Sorted-Array-II)
* [154. Find Minimum in Rotated Sorted Array II](#154-find-minimum-in-rotated-sorted-array-ii)
- similar to 33

### 35. Search Insert Position

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] > target:
                r = m - 1
            elif nums[m] < target:
                l = m + 1
            else:
                return m
        return l
```

### 74. Search a 2D Matrix

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        nums = sum(matrix, [])
        i = bisect_left(nums, target)
        return i < len(nums) and nums[i] == target
```

### 34. Find First and Last Position of Element in Sorted Array

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        # return [bisect_left(nums, target), bisect_right(nums, target) - 1]
        n = len(nums)
        def binary_right(nums, target):
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] > target:
                    r = m - 1
                else:
                    l = m + 1
            return r if r >= 0 and nums[r] == target else -1
        def binary_left(nums, target):
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] < target:
                    l = m + 1
                else:
                    r = m - 1
            return l if l < n and nums[l] == target else -1
        return [binary_left(nums, target), binary_right(nums, target)]
```


### 153. Find Minimum in Rotated Sorted Array

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            m = l + (r - l) // 2
            if nums[m] > nums[r]:
                l = m + 1
            else:
                r = m  
        return nums[l]
```

### 33. Search in Rotated Sorted Array

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == target:
                return m 
            if nums[m] >= nums[l]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else:
                    l = m + 1
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else:
                    r = m - 1
        return -1
```

### 4. Median of Two Sorted Arrays

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        nums1 = [-inf] + nums1 + [inf]
        nums2 = [-inf] + nums2 + [inf]
        A, B, total = nums1, nums2, len(nums1) + len(nums2)
        if len(A) > len(B):
            A, B = B, A 
        half = total // 2

        l, r = 0, len(A) - 1
        while True:
            m1 = l + (r - l) // 2
            m2 = half - m1 - 2
            leftA = A[m1]
            rightA = A[m1 + 1]
            leftB = B[m2]
            rightB = B[m2 + 1]
            if leftA <= rightB and leftB <= rightA:
                if total % 2:
                    return min(rightA, rightB)
                return (max(leftA, leftB) + min(rightA, rightB)) / 2
            elif leftA > rightB:
                r = m1 - 1
            else:
                l = m1 + 1
```

### 81. Search in Rotated Sorted Array II

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == target:
                return True
            if nums[m] > nums[l]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else:
                    l = m + 1
            elif nums[m] < nums[l]:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else:
                    r = m - 1
            else:
                l += 1
        return False
```

### 154. Find Minimum in Rotated Sorted Array II

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            m = l + (r - l) // 2
            if nums[m] > nums[r]:
                l = m + 1
            elif nums[m] < nums[r]:
                r = m  
            else:
                r -= 1
        return nums[l]
```

## greedy

### 121. Best Time to Buy and Sell Stock

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        lowest, profit = prices[0], 0
        for p in prices:
            lowest = min(lowest, p)
            profit = max(profit, p - lowest)
        return profit
```

### 55. Jump Game

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        furthest = 0
        for i in range(n):
            if i <= furthest:
                furthest = max(i + nums[i], furthest)
        return furthest >= n - 1
```

### 45. Jump Game II

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        # method 1: dp
        dp = [0] * len(nums) # last number of dp is the value
        for i in range(1, len(nums)):
            res = inf
            for j in range(i):
                if j + nums[j] >= i:
                    res = min(res, dp[j] + 1)    
                    dp[i] = res
        return dp[-1] # time too long
        
        # method 2: greedy
        # res = 0
        # l, r = 0, 0 # window of indexes
        # while r < len(nums) - 1:
        #     farthest = 0
        #     for i in range(l, r + 1):
        #         farthest = max(farthest, i + nums[i])
        #     l = r + 1
        #     r = farthest
        #     res += 1
        # return res
```

### 763. Partition Labels

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        d = defaultdict(list)
        for i, c in enumerate(s):
            d[c].append(i)

        furthest = 0
        n = len(s)
        i = 0
        res = []
        while i < n:
            furthest = d[s[i]][-1]
            j = i 
            while j < furthest:
                furthest = max(furthest, d[s[j]][-1])
                j += 1
            res.append(furthest - i + 1)
            i = furthest + 1
        return res
```

## DP

### DP 1D (5)

* [70. Climbing Stairs](#70-Climbing-Stairs)
* [118. Pascal's Triangle](#118-Pascal's-Triangle)
* [53. Maximum Subarray](#53-Maximum-Subarray)
* [198. House Robber](#198-House-Robber)
* [152. Maximum Product Subarray](#152-Maximum-Product-Subarray)

### 70. Climbing Stairs

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        first, second = 1, 2
        for i in range(3, n + 1):
            second, first = second + first, second 
        return second if n >= 2 else first
```

### 118. Pascal's Triangle

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = [[1]]
        for i in range(2, numRows + 1):
            lastRow = res[-1]
            lastRow = [0] + lastRow + [0]
            lastRow = [lastRow[i] + lastRow[i + 1] for i in range(len(lastRow) - 1)]
            res.append(lastRow)
        return res
```

### 53. Maximum Subarray

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * n 
        dp[0] = nums[0]
        for i in range(1, n):
            dp[i] = max(nums[i], nums[i] + dp[i - 1])
        return max(dp)
```

### 198. House Robber

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp = [0] * (len(nums) + 1)
        dp[1] = nums[0]
        for i in range(2, len(dp)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
        return dp[-1]
```

### 152. Maximum Product Subarray

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = mx = mn = nums[0]
        n = len(nums)
        for i in range(1, n):
            temp = mx 
            mx = max(mx * nums[i], mn * nums[i], nums[i])
            mn = min(temp * nums[i], mn * nums[i], nums[i])
            res = max(res, mx)
        return res
```


### DP knapsack

* [322. Coin Change](#322-Coin-Change)
* [279. Perfect Squares](#279-Perfect-Squares)
* [53. Maximum Subarray](#53-Maximum-Subarray)

### 322. Coin Change

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        @cache
        def dfs(t, i):
            if t > amount:
                return inf 
            if i == len(coins):
                return 0 if t == amount else inf 
            return min(dfs(t, i + 1), dfs(t + coins[i], i) + 1)
        res = dfs(0, 0)
        return res if res != inf else -1
```

### 279. Perfect Squares

```python
square = [i * i for i in range(100, 0, -1)]
class Solution:
    def numSquares(self, n: int) -> int:
        @cache
        def f(t, i):
            if t > n:
                return inf 
            if i == len(square):
                return 0 if t == n else inf
            return min(f(t, i + 1), f(t + square[i], i) + 1) 
        res = f(0, 0)
        f.cache_clear()
        return res
```

### 416. Partition Equal Subset Sum

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        half = sum(nums) // 2
        @cache
        def f(t, i):
            if i == len(nums):
                return True if t == half else False
            return f(t, i + 1) or f(t + nums[i], i + 1)
        return f(0, 0)
```

### Dp 2D (6)

* [62. Unique Paths](#62-Unique-Paths)
* [64. Minimum Path Sum](#64-Minimum-Path-Sum)
* [1143. Longest Common Subsequence](#1143-Longest-Common-Subsequence)
* [5. Longest Palindromic Substring](#5-Longest-Palindromic-Substring)
* [5. Longest Palindromic Substring](#5-Longest-Palindromic-Substring)
* [72. Edit Distance](#72-Edit-Distance)
* [139. Word Break](#139-Word-Break)

- exercise

* [132. Palindrome Partitioning II](#132-palindrome-partitioning-ii)
* [3144. Minimum Substring Partition of Equal Character Frequency](#3144-minimum-substring-partition-of-equal-character-frequency)

### 62. Unique Paths

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        R, C = m, n
        dp = [[1] * C for i in range(R)]
        for r in range(1, m):
            for c in range(1, n):
                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
        return dp[-1][-1]
```

### 64. Minimum Path Sum

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        for r in range(1, R):
            grid[r][0] += grid[r - 1][0]
        for c in range(1, C):
            grid[0][c] += grid[0][c - 1]
        for r in range(1, R):
            for c in range(1, C):
                grid[r][c] += min(grid[r - 1][c], grid[r][c - 1])
        return grid[-1][-1]
```

### 1143. Longest Common Subsequence

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        R, C = len(text1) + 1, len(text2) + 1
        dp = [[0] * C for r in range(R)]
        for r in range(1, R):
            for c in range(1, C):
                if text1[r - 1] != text2[c - 1]:
                    dp[r][c] = max(dp[r - 1][c], dp[r][c - 1])
                else:
                    dp[r][c] = dp[r - 1][c - 1] + 1
        return dp[-1][-1]
```

### 5. Longest Palindromic Substring

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n, res = len(s), s[0]
        dp = [[False] * n for r in range(n)]
        for r in range(1, n):
            for l in range(r):
                if s[r] == s[l] and (r - l + 1 <= 3 or dp[l + 1][r - 1]):
                    dp[l][r] = True
                    if r - l + 1 > len(res):
                        res = s[l: r + 1]
        return res 
```

### 72. Edit Distance

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        R, C = len(word1) + 1, len(word2) + 1
        dp = [[0] * C for r in range(R)]
        for c in range(1, C):
            dp[0][c] = dp[0][c - 1] + 1
        for r in range(1, R):
            dp[r][0] = dp[r - 1][0] + 1
        for r in range(1, R):
            for c in range(1, C):
                if word1[r - 1] == word2[c - 1]:
                    dp[r][c] = dp[r - 1][c - 1]
                else:
                    dp[r][c] = min(dp[r][c - 1], dp[r - 1][c], dp[r - 1][c - 1]) + 1
        return dp[-1][-1]
```


### 139. Word Break

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n, wordDict = len(s), set(wordDict)
        dp = [True] + [False] * n
        for i in range(n + 1):
            for j in range(i + 1, n + 1):
                if dp[i] and s[i:j] in wordDict:
                    dp[j] = True
        return dp[-1]
```

### 132. Palindrome Partitioning II

```python
class Solution:
    def minCut(self, s: str) -> int:
        @cache
        def dfs(i):
            if i == n:
                return 0
            res = inf 
            for j in range(i, n):
                if dp[i][j]:
                    res = min(res, dfs(j + 1) + 1)
            return res
        n = len(s)
        dp = [[False] * n for c in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):
                    dp[i][j] = True
        return dfs(0) - 1
```

### 3144. Minimum Substring Partition of Equal Character Frequency

```python
class Solution:
    def minimumSubstringsInPartition(self, s: str) -> int:
        @cache
        def dfs(i):
            if i >= len(s):
                return 0
            c = Counter()
            res = inf
            for j in range(i, n):
                c[s[j]] += 1
                if len(set(c.values())) == 1:
                    res = min(res, dfs(j + 1) + 1)
            return res
        n = len(s)
        return dfs(0)
```

## greedy (4)

* [121. Best Time to Buy and Sell Stock](#121-Best-Time-to-Buy-and-Sell-Stock)
* [55. Jump Game](#55-Jump-Game)
* [45. Jump Game II](#45-Jump-Game-II)
* [763. Partition Labels](#763-Partition-Labels)

## Tricks (5)

* [136. Single Number](#136-Single-Number)
* [189. Rotate Array](#189-Rotate-Array)
* [169. Majority Element](#169-Majority-Element)
* [31. Next Permutation](#31-Next-Permutation)
* [75. Sort Colors](#75-Sort-Colors)

### 136. Single Number

- bit manipulation

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for n in nums:
            res ^= n 
        return res
```
### 189. Rotate Array

- reverse

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k = k % n 
        nums.reverse()
        l, r = 0, k - 1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
        l, r = k, n - 1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
```


### 169. Majority Element

- Moore Voting

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        for n in nums:
            if count == 0:
                major = n 
                count = 1
            elif n == major:
                count += 1
            else:
                count -= 1
        return major
```

### 31. Next Permutation

- math

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        pivot = None
        n = len(nums)
        for i in range(n - 1, 0, -1):
            if nums[i] > nums[i - 1]:
                pivot = i - 1
                break
        if pivot == None:
            nums.reverse()
            return 
        
        for i in range(n - 1, 0, -1):
            if nums[i] > nums[pivot]:
                nums[i], nums[pivot] = nums[pivot], nums[i]
                break 
        print(pivot)
        nums[pivot + 1:] = nums[pivot + 1:][::-1]
```

### 75. Sort Colors

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i, l, r = 0, 0, len(nums) - 1
        while i <= r:
            if nums[i] == 2:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
            elif nums[i] == 0:
                nums[i], nums[l] = nums[l], nums[i]
                l += 1
                i += 1
            else:
                i += 1
```