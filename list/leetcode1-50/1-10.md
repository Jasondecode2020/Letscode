## Note

* [1. Two Sum](#1-Two-Sum)
* [2. Add Two Numbers](#2-add-two-numbers)
* [3. Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
* [4. Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
* [5. Longest Palindromic Substring](#5-longest-palindromic-substring)
* [6. Zigzag Conversion](#6-zigzag-conversion)
* [7. Reverse Integer](#7-reverse-integer)
* [8. String to Integer (atoi)](#8-string-to-integer-atoi)
* [9. Palindrome Number](#9-palindrome-number)
* [10. Regular Expression Matching](#10-regular-expression-matching)

1. hash table - (23s)
2. linked list - (59s)
3. sliding window - (31s)
4. binary search - (156s)
5. two pointers - (51s)(dp: 73s)
6. bucket sort - (57s)
7. math - (48s)
8. string - (60s)
9. math - (36s)
10. dp - (79s)

### 1. Two Sum

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i, n in enumerate(nums):
            res = target - n 
            if res in d:
                return [d[res], i]
            d[n] = i 
```

### 2. Add Two Numbers

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        c = 0
        while l1 or l2 or c:
            val = c + (l1.val if l1 else 0) + (l2.val if l2 else 0)
            if l1: l1 = l1.next 
            if l2: l2 = l2.next 
            c, d = divmod(val, 10)
            p.next = ListNode(d)
            p = p.next 
        return dummy.next 
```

### 3. Longest Substring Without Repeating Characters

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l, res, d = 0, 0, {}
        for r, c in enumerate(s):
            if c in d:
                l = max(l, d[c] + 1)
            res = max(res, r - l + 1)
            d[c] = r 
        return res 
```

### 4. Median of Two Sorted Arrays

- binary search
- https://www.youtube.com/watch?v=LPFhl65R7ww&t=1224s
- https://www.youtube.com/watch?v=q6IEA26hvXc

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        A, B, total = nums1, nums2, len(nums1) + len(nums2)
        half = total // 2
        if len(A) > len(B): A, B = B, A
        lengthA, lengthB = len(A), len(B)
        l, r = 0, lengthA - 1
        while True:
            i = (l + r) // 2
            j = half - i - 2
            leftA = A[i] if i >= 0 else -inf
            rightA = A[i + 1] if i + 1 < lengthA else inf
            leftB = B[j] if j >= 0 else -inf
            rightB = B[j + 1] if j + 1 < lengthB else inf
            if leftA <= rightB and leftB <= rightA:
                if total % 2:
                    return min(rightA, rightB)
                return (max(leftA, leftB) + min(rightA, rightB)) / 2
            elif leftA > rightB:
                r = i - 1
            else:
                l = i + 1
```

### 5. Longest Palindromic Substring

- two pointers spread

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def helper(l, r):
            while l >= 0 and r < n and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l + 1: r]
        
        res, n = '', len(s)
        for i in range(n):
            res = max(res, helper(i, i), helper(i, i + 1), key = len)
        return res 
```

- dp

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        f = [[False] * n for _ in range(n)]
        res = s[0]
        for j in range(1, n):
            for i in range(j):
                if s[i] == s[j] and (j - i <= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                    res = max(res, s[i: j + 1], key = len)
        return res 
```
### 6. Zigzag Conversion

- bucket sort

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1: return s 
        rows = [[] for _ in range(numRows)]
        i, step = 0, -1
        for c in s:
            rows[i].append(c)
            if i == 0 or i == numRows - 1:
                step *= -1 
            i += step 
        return ''.join(''.join(r) for r in rows)
```

### 7. Reverse Integer

```python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MAX = 2 ** 31 - 1
        sign = 1 if x > 0 else -1
        res, x = 0, abs(x)
        while x:
            y = res * 10 + x % 10
            if y > INT_MAX:
                return 0 
            res = y 
            x //= 10
        return sign * res 
```

### 8. String to Integer (atoi)

- string

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        s, res = s.strip(), 0
        if not s: return 0 
        sign = -1 if s[0] == '-' else 1 
        s = s[1:] if s[0] in '+-' else s 
        for c in s:
            if not c.isdigit():
                break 
            res = res * 10 + int(c)
        return max(-2 ** 31, min(sign * res, 2 ** 31 - 1))
```

### 9. Palindrome Number

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0: return False
        res, origin = 0, x 
        while x:
            res = res * 10 + x % 10
            x //= 10 
        return res == origin
```

### 10. Regular Expression Matching

- https://www.youtube.com/watch?v=HAA8mgxlov8
- dp

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        @cache
        def dfs(i, j):
            if i >= len(s) and j >= len(p):
                return True
            if j >= len(p):
                return False
            match = i < len(s) and (s[i] == p[j] or p[j] == '.')
            if j + 1 < len(p) and p[j + 1] == '*':
                return match and dfs(i + 1, j) or dfs(i, j + 2)
            return match and dfs(i + 1, j + 1)
        return dfs(0, 0)
```