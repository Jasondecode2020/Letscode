## Note

* [21. Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [22. Generate Parentheses](#22-generate-parentheses)
* [13. Roman to Integer](#13-roman-to-integer)
* [14. Longest Common Prefix](#14-longest-common-prefix)
* [15. 3Sum](#15-3sum)
* [16. 3Sum Closest](#16-3sum-closest)
* [17. Letter Combinations of a Phone Number](#17-letter-combinations-of-a-phone-number)
* [18. 4Sum](#18-4sum)
* [19. Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [20. Valid Parentheses](#20-valid-parentheses)

21. linked list (59s)
22. backtrack (94s)
23. linked list
24. linked list
25. linked list
26. two pointers
27. two pointers
28. KMP
29. Exponential Search
30. hash table

- should be easier as there are no hard questions

> first time: need to do 18, 20
> second time: need to do 18

### 21. Merge Two Sorted Lists

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = p = ListNode()
        while list1 and list2:
            if list1.val > list2.val:
                p.next = list2
                list2 = list2.next 
            else:
                p.next = list1
                list1 = list1.next 
            p = p.next 
        p.next = list1 or list2 
        return dummy.next 
```

### 22. Generate Parentheses

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def backtrack(openN, closeN, ans):
            if openN == closeN == n:
                res.append(ans)
                return 
            if openN < n:
                backtrack(openN + 1, closeN, ans + '(')
            if closeN < n and closeN < openN:
                backtrack(openN, closeN + 1, ans + ')')
        res = []
        backtrack(0, 0, '')
        return res 
```

### 23. Merge k Sorted Lists

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        h = []
        for l in lists:
            while l:
                heappush(h, l.val)
                l = l.next 
        p = dummy = ListNode()
        while h:
            p.next = ListNode(heappop(h))
            p = p.next 
        return dummy.next 
```

### 24. Swap Nodes in Pairs

```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        k = 0
        p = dummy = ListNode()
        p.next = head 
        while head:
            k += 1
            head = head.next 

        prev, cur = p, p.next 
        for _ in range(k // 2):
            nxt = cur.next 
            cur.next = nxt.next 
            nxt.next = prev.next 
            prev.next = nxt 
            prev, cur = cur, cur.next 
        return dummy.next 
```

### 25. Reverse Nodes in k-Group

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        K = 0
        p = dummy = ListNode()
        p.next = head 
        while head:
            K += 1
            head = head.next 

        prev, cur = p, p.next 
        for _ in range(K // k):
            for _ in range(k - 1):
                nxt = cur.next 
                cur.next = nxt.next 
                nxt.next = prev.next 
                prev.next = nxt 
            prev, cur = cur, cur.next 
        return dummy.next 
```

### 26. Remove Duplicates from Sorted Array

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        k = 0
        for i in range(1, len(nums)):
            if nums[i] != nums[k]:
                k += 1
                nums[k] = nums[i]
        return k + 1 
```

### 27. Remove Element

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k, r = 0, len(nums) - 1
        while k <= r:
            if nums[k] == val:
                nums[k] = nums[r]
                r -= 1
            else:
                k += 1
        return k
```

### 28. Find the Index of the First Occurrence in a String

- KMP: https://www.youtube.com/watch?v=V5-7GzOfADQ

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n, pattern = len(needle), hash(needle)
        for i in range(len(haystack)):
            if hash(haystack[i:i+n]) == pattern:
                return i
        return -1
```

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        def nxt(s):
            nxt, j = [-1], -1
            for i in range(len(s)):
                while j >= 0 and s[i] != s[j]:
                    j = nxt[j]
                j += 1
                nxt.append(j)
            return nxt 

        s, p = haystack, needle
        nxt = nxt(needle)
        j = 0 
        for i in range(len(s)):
            while j >= 0 and s[i] != p[j]:
                j = nxt[j]
            j += 1
            if j == len(p):
                return i - len(p) + 1
        return -1
```

### 29. Divide Two Integers

- Exponential Search

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        if dividend == -2 ** 31 and divisor == -1:
            return 2 ** 31 - 1
        a, b, res = abs(dividend), abs(divisor), 0
        for i in range(31, -1, -1):
            if (b << i) <= a:
                res += 1 << i
                a -= b << i
        return res if (dividend > 0) == (divisor > 0) else -res
```

### 30. Substring with Concatenation of All Words

```python
# TLE
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        ans, n, m, words  = [], len(words), len(words[0]), Counter(words)
        for i in range(len(s) - n * m + 1):
            tmp, cnt = Counter(), 0
            for j in range(i, i + n * m, m):
                w = s[j: j + m]
                if w in words:
                    tmp[w] += 1
                    cnt += 1
                    if tmp[w] > words[w]: 
                        break
                    if cnt == n:
                        ans.append(i)
        return ans

class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        word_len, total_words = len(words[0]), len(words)
        total_len = word_len * total_words
        word_count, res = Counter(words), []
        
        for i in range(word_len):
            l = r = i
            current_count = Counter()
            while r + word_len <= len(s):
                word = s[r:r + word_len]
                r += word_len
                if word in word_count:
                    current_count[word] += 1
                    while current_count[word] > word_count[word]:
                        left_word = s[l:l + word_len]
                        current_count[left_word] -= 1
                        l += word_len
                    if r - l == total_len:
                        res.append(l)
                else:
                    current_count.clear()
                    l = r
        return res
```

