## Note

* [11. Container With Most Water](#11-container-with-most-water)
* [12. Integer to Roman](#12-integer-to-roman)
* [13. Roman to Integer](#13-roman-to-integer)
* [14. Longest Common Prefix](#14-longest-common-prefix)
* [15. 3Sum](#15-3sum)
* [16. 3Sum Closest](#16-3sum-closest)
* [17. Letter Combinations of a Phone Number](#17-letter-combinations-of-a-phone-number)
* [18. 4Sum](#18-4sum)
* [19. Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [20. Valid Parentheses](#20-valid-parentheses)

11. two pointers (35s)
12. math (111s)
13. math (87s) 
14. string (27s) 
15. two pointers (120s)
16. two pointers (53s)
17. backtrack (133s)
18. two pointers (59s)
19. linked list (50s)
20. stack (80s)

### 11. Container With Most Water

- two pointers

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r, res = 0, len(height) - 1, 0
        while l < r:
            a, b = height[l], height[r]
            res = max(res, min(a, b) * (r - l))
            if a < b: l += 1
            else: r -= 1
        return res 
```

### 12. Integer to Roman

- math

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        symbol = ['M', 'CM', 'D', 'CD','C', 'XC', 'L', 'XL','X', 'IX', 'V', 'IV', 'I']
        res = ''
        for v, s in zip(value, symbol):
            res += num // v * s 
            num %= v 
        return res 
```

### 13. Roman to Integer

- math

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        res = d[s[0]]
        for i in range(1, len(s)):
            res += d[s[i]]
            if d[s[i]] > d[s[i - 1]]:
                res -= 2 * d[s[i - 1]]
        return res
```

### 14. Longest Common Prefix

- string

```python
 class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        first = strs[0]
        for i, c in enumerate(first):
            for s in strs:
                if i == len(s) or s[i] != c:
                    return first[: i]
        return first 
```

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        t = Trie()
        for word in strs:
            t.insert(word)

        res = ''
        cur = t.root
        while cur:
            if len(cur.children) > 1 or cur.endOfWord: # if a word ends or has more than one children
                break
            c = list(cur.children.keys())[0]
            cur = cur.children[c]
            res += c
        return res
```

### 15. 3Sum

- two pointers

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        s, n = set(), len(nums)
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, n - 1
            while l < r:
                total = sum([nums[i], nums[l], nums[r]])
                if total == 0:
                    s.add((nums[i], nums[l], nums[r]))
                    l += 1
                    r -= 1
                elif total < 0:
                    l += 1
                else:
                    r -= 1
        return list(s)
```

### 16. 3Sum Closest

- two pointers

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        res, n = inf, len(nums)
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, n - 1
            while l < r:
                total = sum([nums[i], nums[l], nums[r]])
                if abs(total - target) < abs(res - target):
                    res = total
                if total < target:
                    l += 1
                else:
                    r -= 1
        return res
```

### 17. Letter Combinations of a Phone Number

- recursive and iterative

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res = ['']
        for n in digits:
            letters = d[n]
            ans = []
            for item in res:
                for c in letters:
                    ans.append(item + c)
            res = ans
        return res if digits else []
```

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res, n = [], len(digits)
        def backtrack(i, ans):
            if i == n:
                if ans:
                    res.append(ans)
                return
            for c in d[digits[i]]:
                backtrack(i + 1, ans + c)
        backtrack(0, '')
        return res 
```

### 18. 4Sum

- two pointers

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        s, n = set(), len(nums)
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, n):
                l, r = j + 1, n - 1
                while l < r:
                    total = sum([nums[i], nums[j], nums[l], nums[r]])
                    if total == target:
                        s.add((nums[i], nums[j], nums[l], nums[r]))
                        l += 1
                        r -= 1
                    elif total < target:
                        l += 1
                    else:
                        r -= 1
        return list(s)
```

### 19. Remove Nth Node From End of List

- linked list

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = slow = fast = ListNode()
        dummy.next = head
        for i in range(n + 1):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```

### 20. Valid Parentheses

- stack

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack, valid = [], ['{}', '[]', '()']
        for c in s:
            if stack and any([c == valid[i][1] and stack[-1] == valid[i][0] for i in range(len(valid))]):
                stack.pop()
            else:
                stack.append(c)
        return not stack
```