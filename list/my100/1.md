# My 100(climbing stairs, robbing house, Maximum Subarray sum, grid dp, knapsack, lcs, lis)

## Question List(1-10)

* [5. Longest Palindromic Substring](#5-longest-palindromic-substring)
* [647. Palindromic Substrings](#647-palindromic-substrings)
* [516. Longest Palindromic Subsequence](#516-longest-palindromic-subsequence)
* [1682. Longest Palindromic Subsequence II](#1682-longest-palindromic-subsequence-ii)
* [70. Climbing Stairs](#70-climbing-stairs)
* [509. Fibonacci Number](#509-fibonacci-number) 
* [1137. N-th Tribonacci Number](#1137-n-th-tribonacci-number) 
* [746. Min Cost Climbing Stairs](#746-min-cost-climbing-stairs) 
* [377. Combination Sum IV](#377-combination-sum-iv) 
* [2466. Count Ways To Build Good Strings](#2466-count-ways-to-build-good-strings) 

## Question List(11-20)

* [2533. Number of Good Binary Strings](#2533-number-of-good-binary-strings) 
* [2266. Count Number of Texts](#2266-count-number-of-texts)
* [2400. Number of Ways to Reach a Position After Exactly k Steps](#2400-number-of-ways-to-reach-a-position-after-exactly-k-steps)
* [198. House Robber](#198-house-robber) 
* [740. Delete and Earn](#740-delete-and-earn) 
* [213. House Robber II](#213-house-robber-ii) 
* [2320. Count Number of Ways to Place Houses](#2320-count-number-of-ways-to-place-houses) 
* [256. Paint House](#256-paint-house) 
* [265. Paint House II](#265-paint-house-ii) 
* [276. Paint Fence](#276-paint-fence) 

## Question List(21-30)

* [3186. Maximum Total Damage With Spell Casting](#3186-maximum-total-damage-with-spell-casting)
* [2140. Solving Questions With Brainpower](#2140-solving-questions-with-brainpower)
* [53. Maximum Subarray](#53-maximum-subarray) 1400
* [2606. Find the Substring With Maximum Cost](#2606-find-the-substring-with-maximum-cost) 1422
* [1749. Maximum Absolute Sum of Any Subarray](#1749-maximum-absolute-sum-of-any-subarray) 1542
* [1191. K-Concatenation Maximum Sum](#1191-k-concatenation-maximum-sum) 1748
* [918. Maximum Sum Circular Subarray](#918-maximum-sum-circular-subarray) 1777
* [2321. Maximum Score Of Spliced Array](#2321-maximum-score-of-spliced-array) 1791
* [152. Maximum Product Subarray](#152-maximum-product-subarray) 1800
* [62. Unique Paths](#62-unique-paths)

## Question List(31-40)

* [63. Unique Paths II](#63-unique-paths-ii)
* [64. Minimum Path Sum](#64-minimum-path-sum)
* [120. Triangle](#120-triangle)
* [3393. Count Paths With the Given XOR Value](#3393-count-paths-with-the-given-xor-value)
* [931. Minimum Falling Path Sum](#931-minimum-falling-path-sum)
* [2684. Maximum Number of Moves in a Grid](#2684-maximum-number-of-moves-in-a-grid)
* [1289. Minimum Falling Path Sum II](#1289-minimum-falling-path-sum-ii)
* [2304. Minimum Path Cost in a Grid](#2304-minimum-path-cost-in-a-grid)
* [3418. Maximum Amount of Money Robot Can Earn](#3418-maximum-amount-of-money-robot-can-earn)
* [1594. Maximum Non Negative Product in a Matrix](#1594-maximum-non-negative-product-in-a-matrix)

## Question List(41-50)

* [1301. Number of Paths with Max Score](#1301-number-of-paths-with-max-score)
* [2435. Paths in Matrix Whose Sum Is Divisible by K](#2435-paths-in-matrix-whose-sum-is-divisible-by-k) 1951
* [174. Dungeon Game](#174-dungeon-game)
* [329. Longest Increasing Path in a Matrix](#329-longest-increasing-path-in-a-matrix)
* [2328. Number of Increasing Paths in a Grid](#2328-number-of-increasing-paths-in-a-grid)
* [2267. Check if There Is a Valid Parentheses String Path](#2267-check-if-there-is-a-valid-parentheses-string-path)
* [2510. Check if There is a Path With Equal Number of 0's And 1's](#2510-check-if-there-is-a-path-with-equal-number-of-0s-and-1s)
* [1937. Maximum Number of Points with Cost](#1937-maximum-number-of-points-with-cost)
* [1463. Cherry Pickup II](#1463-cherry-pickup-ii)
* [741. Cherry Pickup](#741-cherry-pickup)

## Question List(51-60)

* [1824. Minimum Sideway Jumps](#1824-minimum-sideway-jumps)
* [3363. Find the Maximum Number of Fruits Collected](#3363-find-the-maximum-number-of-fruits-collected)
* [3459. Length of Longest V-Shaped Diagonal Segment](#3459-length-of-longest-v-shaped-diagonal-segment)
* [2915. Length of the Longest Subsequence That Sums to Target](#2915-Length-of-the-Longest-Subsequence-That-Sums-to-Target)
* [416. Partition Equal Subset Sum](#2915-Length-of-the-Longest-Subsequence-That-Sums-to-Target)
* [494. Target Sum](#494-Target-Sum)
* [2787. Ways to Express an Integer as Sum of Powers](#2787-ways-to-express-an-integer-as-sum-of-powers)
* [3180. Maximum Total Reward Using Operations I](#3180-maximum-total-reward-using-operations-i)
* [474. Ones and Zeroes](#474-ones-and-zeroes)
* [1049. Last Stone Weight II](#1049-last-stone-weight-ii)

## Question List(61-70)

* [1774. Closest Dessert Cost](#1774-closest-dessert-cost)
* [879. Profitable Schemes](#2915-Length-of-the-Longest-Subsequence-That-Sums-to-Target)
* [805. Split Array With Same Average](#2915-Length-of-the-Longest-Subsequence-That-Sums-to-Target)
* [923. 3Sum With Multiplicity](#2915-Length-of-the-Longest-Subsequence-That-Sums-to-Target)
* [2291. Maximum Profit From Trading Stocks](#2291-maximum-profit-from-trading-stocks)
* [3082. Find the Sum of the Power of All Subsequences](#3082-find-the-sum-of-the-power-of-all-subsequences)
* [322. Coin Change](#322-coin-change)
* [518. Coin Change II](#518-coin-change-ii)
* [279. Perfect Squares](#279-perfect-squares)
* [377. Combination Sum IV](#377-combination-sum-iv-unbounded-knapsack-with-sequence)

## Question List(71-80)

* [1449. Form Largest Integer With Digits That Add up to Target](#1449-form-largest-integer-with-digits-that-add-up-to-target)
* [3183. The Number of Ways to Make the Sum](#3183-the-number-of-ways-to-make-the-sum)
* [1155. Number of Dice Rolls With Target Sum](#1155-number-of-dice-rolls-with-target-sum)
* [1981. Minimize the Difference Between Target and Chosen Elements](#1981-minimize-the-difference-between-target-and-chosen-elements)
* [2218. Maximum Value of K Coins From Piles](#2218-maximum-value-of-k-coins-from-piles)
* [1143. Longest Common Subsequence](#1143-longest-common-subsequence)
* [583. Delete Operation for Two Strings](#583-delete-operation-for-two-strings)
* [712. Minimum ASCII Delete Sum for Two Strings](#712-minimum-ascii-delete-sum-for-two-strings)
* [72. Edit Distance](#72-edit-distance)
* [97. Interleaving String](#97-interleaving-string)

## Question List(81-90)

* [115. Distinct Subsequences](#115-distinct-subsequences)
* [1035. Uncrossed Lines](#1035-uncrossed-lines)
* [1458. Max Dot Product of Two Subsequences](#1458-max-dot-product-of-two-subsequences)
* [1092. Shortest Common Supersequence](#1092-shortest-common-supersequence)
* [1639. Number of Ways to Form a Target String Given a Dictionary](#1639-number-of-ways-to-form-a-target-string-given-a-dictionary)
* [161. One Edit Distance](#161-one-edit-distance)
* [516. Longest Palindromic Subsequence](#516-longest-palindromic-subsequence)
* [1312. Minimum Insertion Steps to Make a String Palindrome](#1312-minimum-insertion-steps-to-make-a-string-palindrome)
* [44. Wildcard Matching](#44-wildcard-matching)
* [10. Regular Expression Matching](#10-regular-expression-matching)

## Question List(91-100)

* [300. Longest Increasing Subsequence](#300-longest-increasing-subsequence)
* [334. Increasing Triplet Subsequence](#334-increasing-triplet-subsequence)
* [646. Maximum Length of Pair Chain](#646-maximum-length-of-pair-chain)
* [673. Number of Longest Increasing Subsequence](#673-number-of-longest-increasing-subsequence)
* [2826. Sorting Three Groups](#2826-sorting-three-groups)
* [1671. Minimum Number of Removals to Make Mountain Array](#1671-minimum-number-of-removals-to-make-mountain-array)
* [1964. Find the Longest Valid Obstacle Course at Each Position](#1964-find-the-longest-valid-obstacle-course-at-each-position)
* [1626. Best Team With No Conflicts](#1626-best-team-with-no-conflicts)
* [354. Russian Doll Envelopes](#354-russian-doll-envelopes)
* [1691. Maximum Height by Stacking Cuboids](#1691-maximum-height-by-stacking-cuboids)

## Question List(101-110)

* [1027. Longest Arithmetic Subsequence](#1027-longest-arithmetic-subsequence)
* [2770. Maximum Number of Jumps to Reach the Last Index](#2770-maximum-number-of-jumps-to-reach-the-last-index)
* [2111. Minimum Operations to Make the Array K-Increasing](#2111-minimum-operations-to-make-the-array-k-increasing)
* [960. Delete Columns to Make Sorted III](#960-delete-columns-to-make-sorted-iii)
* [2407. Longest Increasing Subsequence II](#2407-longest-increasing-subsequence-ii)
* [1187. Make Array Strictly Increasing](#1187-make-array-strictly-increasing)
* [1713. Minimum Operations to Make a Subsequence](#1713-minimum-operations-to-make-a-subsequence)
* [3288. Length of the Longest Increasing Path](#3288-length-of-the-longest-increasing-path)
* [3489. Zero Array Transformation IV](#3489-zero-array-transformation-iv)
* [718. Maximum Length of Repeated Subarray](#718-maximum-length-of-repeated-subarray)

## Question List(111-112)

* [3290. Maximum Multiplication Score](#3290-maximum-multiplication-score)
* [3316. Find Maximum Removals From Source String](#3316-find-maximum-removals-from-source-string)

### 5. Longest Palindromic Substring

- center spreading

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def helper(i, j):
            while i >= 0 and j < n and s[i] == s[j]:
                i -= 1
                j += 1
            return s[i + 1: j]
        
        n, res = len(s), ''
        for i in range(n):
            res = max(res, helper(i, i), helper(i, i + 1), key = len)
        return res 
```

- dp

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n, res = len(s), ''
        f = [[False] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i <= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                    res = max(res, s[i: j + 1], key = len)
        return res 
```

### 647. Palindromic Substrings

- center spreading

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        def helper(i, j):
            res = 0
            while i >= 0 and j < n and s[i] == s[j]:
                i -= 1
                j += 1
                res += 1
            return res
        
        n, res = len(s), 0
        for i in range(n):
            res += helper(i, i) + helper(i, i + 1)
        return res 
```

- dp

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        n, res = len(s), 0
        f = [[False] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i <= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                    res += 1
        return res 
```

### 516. Longest Palindromic Subsequence

- dfs + cache

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        @cache
        def dfs(i, j):
            if j < i:
                return 0
            if i == j:
                return 1
            res = 0
            if s[i] == s[j]:
                res = max(res, dfs(i + 1, j - 1) + 2)
            else:
                res = max(res, dfs(i + 1, j), dfs(i, j - 1))
            return res 
        return dfs(0, len(s) - 1)
```

- dp

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            f[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1] + 2
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return f[0][n - 1]
```

### 1682. Longest Palindromic Subsequence II

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        @cache 
        def dfs(i, j, prev):
            if i >= j:
                return 0
            res = 0
            if s[i] == s[j] and s[i] != prev:
                res += dfs(i + 1, j - 1, s[i]) + 2
            else:
                res += max(dfs(i + 1, j, prev), dfs(i, j - 1, prev))
            return res 
        return dfs(0, len(s) - 1, None)
```

### 70. Climbing Stairs

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        first, second = 1, 2
        for n in range(3, n + 1):
            second, first = second + first, second 
        return second if n >= 2 else 1
```

### 509. Fibonacci Number

```python
class Solution:
    def fib(self, n: int) -> int:
        first, second = 0, 1
        for i in range(2, n + 1):
            second, first = first + second, second
        return second if n >= 1 else 0
```

### 1137. N-th Tribonacci Number

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        first, second, third = 0, 1, 1
        for i in range(3, n + 1):
            third, second, first = third + second + first, third, second
        return third if n >= 1 else first
```

### 746. Min Cost Climbing Stairs

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        for i in range(2, n):
            cost[i] += min(cost[i - 2], cost[i - 1])
        return min(cost[-2:])
```

### 377. Combination Sum IV 

- (unbounded knapsack)

- climbing stairs idea

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache
        def f(x):
            if x == target:
                return 1
            if x > target:
                return 0
            res = 0
            for n in nums:
                res += f(x + n)
            return res 
        return f(0)
```

### 2466. Count Ways To Build Good Strings

- same as 2533 (unbounded knapsack), use t from low to high is better

```python
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def f(t):
            if t == 0:
                return 1
            if t < 0:
                return 0
            res = 0
            for n in [zero, one]:
                res = (res + f(t - n)) % mod
            return res 
        return sum(f(i) for i in range(low, high + 1)) % mod
```

### 2533. Number of Good Binary Strings

- same as 2466 (unbounded knapsack)

```python
class Solution:
    def goodBinaryStrings(self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def f(t):
            if t == 0:
                return 1
            if t < 0:
                return 0
            res = 0
            for x in [oneGroup, zeroGroup]:
                res = (res + f(t - x)) % mod
            return res
        return sum(f(i) for i in range(minLength, maxLength + 1)) % mod 
```

### 2266. Count Number of Texts

```python
class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        mod = 10 ** 9 + 7
        def f(c, count):
            first, second, third, fourth = 1, 1, 2, 4
            for _ in range(4, count + 1):
                if c in '234568':
                    fourth, third, second, first = fourth + third + second, fourth, third, second 
                else:
                    fourth, third, second, first = fourth + third + second + first, fourth, third, second 
            return fourth % mod 
        res = 1
        for c, s in groupby(pressedKeys):
            count = len(list(s))
            if count <= 2:
                res = (res * count) % mod 
            else:
                res = (res * f(c, count)) % mod 
        return res 
```

### 2400. Number of Ways to Reach a Position After Exactly k Steps

```python
class Solution:
    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def dfs(pos, step):
            if step == k:
                return pos == endPos
            if abs(pos - endPos) > k:
                return 0
            return (dfs(pos + 1, step + 1) + dfs(pos - 1, step + 1)) % mod
        return dfs(startPos, 0)
```

### 198. House Robber

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        nums = [0] + nums
        n = len(nums)
        for i in range(2, n):
            nums[i] = max(nums[i - 1], nums[i] + nums[i - 2])
        return nums[-1]
```

### 740. Delete and Earn

```python
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        f = [0] * (max(nums) + 1)
        for n in nums:
            f[n] += n
        
        n = len(f)
        for i in range(2, n):
            f[i] = max(f[i - 1], f[i] + f[i - 2])
        return f[-1]
```

### 213. House Robber II

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        def rob1(nums):
            nums = [0] + nums 
            n = len(nums)
            for i in range(2, n):
                nums[i] = max(nums[i - 1], nums[i] + nums[i - 2])
            return nums[-1]
        return max(rob1(nums[1:]), rob1(nums[:-1])) if len(nums) > 1 else nums[0]
```

### 2320. Count Number of Ways to Place Houses

```python
class Solution:
    def countHousePlacements(self, n: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def f(i, rob):
            if i == n:
                return 1
            res = 0
            if rob:
                res += f(i + 1, not rob)
            else:
                res += f(i + 1, rob) + f(i + 1, not rob)
            return res 
        res = f(0, False) % mod 
        return (res * res) % mod
```

### 256. Paint House

```python
class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        n = len(costs)
        for i in range(1, n):
            for j in range(3):
                costs[i][j] += min(costs[i - 1][:j] + costs[i - 1][j + 1:])
        return min(costs[-1])
```

### 265. Paint House II

```python
class Solution:
    def minCostII(self, costs: List[List[int]]) -> int:
        n = len(costs)
        for i in range(1, n):
            for j in range(len(costs[0])):
                costs[i][j] += min(costs[i - 1][:j] + costs[i - 1][j + 1:])
        return min(costs[-1])
```

### 276. Paint Fence

```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        @cache
        def dfs(i):
            if i == 1:
                return k 
            if i == 2:
                return k * k
            return (dfs(i - 1) + dfs(i - 2)) * (k - 1)
        return dfs(n)
```

### 3186. Maximum Total Damage With Spell Casting

```python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        cnt = Counter(power)
        power = sorted(cnt.keys())
        n = len(power)
        @cache
        def dfs(i):
            if i < 0:
                return 0
            x = power[i]
            j = i - 1
            while j >= 0 and x - power[j] <= 2:
                j -= 1
            return max(dfs(i - 1), dfs(j) + x * cnt[x])
        return dfs(n - 1)
```

### 2140. Solving Questions With Brainpower

```python
class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        @cache
        def dfs(i):
            if i >= n:
                return 0
            return max(dfs(i + 1), dfs(i + questions[i][1] + 1) + questions[i][0])
        n = len(questions)
        return dfs(0)
```


### 53. Maximum Subarray

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(1, n):
            nums[i] = max(nums[i], nums[i - 1] + nums[i])
        return max(nums)
```

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        @cache
        def dfs(l, r):
            if l == r:
                return nums[l]
            m = (l + r) // 2
            left, res = -inf, 0
            for i in range(m, l - 1, -1):
                res += nums[i]
                left = max(left, res)
            right, res = -inf, 0
            for i in range(m + 1, r + 1):
                res += nums[i]
                right = max(right, res)
            return max(dfs(l, m), dfs(m + 1, r), left + right)
        return dfs(0, len(nums) - 1)
```

### 2606. Find the Substring With Maximum Cost

```python
class Solution:
    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        f = [0] * len(s)
        d = {c: v for c, v in zip(chars, vals)}
        for i, c in enumerate(s):
            if c in chars:
                f[i] = d[c]
            else:
                f[i] = ord(c) - ord('a') + 1
        n = len(f)
        for i in range(1, n):
            f[i] = max(f[i], f[i] + f[i - 1])
        return max(f + [0])
```

### 1749. Maximum Absolute Sum of Any Subarray

```python
class Solution:
    def maxAbsoluteSum(self, nums: List[int]) -> int:
        mx, mn, res = 0, 0, 0
        for n in nums:
            mx = max(mx + n, n)
            mn = min(mn + n, n)
            res = max(res, mx, abs(mn))
        return res
```

### 1191. K-Concatenation Maximum Sum

```python
class Solution:
    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:
        def max_subarray_sum(nums):
            n = len(nums)
            for i in range(1, n):
                nums[i] = max(nums[i], nums[i - 1] + nums[i])
            return max(nums + [0])
        if k == 1:
            return max_subarray_sum(arr)
        arr2 = arr * 2 
        s = sum(arr)
        res = max_subarray_sum(arr2)
        mod = 10 ** 9 + 7
        return ((k - 2) * s + res) % mod if s > 0 else res % mod 
```

### 918. Maximum Sum Circular Subarray

```python
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        def max_subarray_sum(nums):
            n = len(nums)
            for i in range(1, n):
                nums[i] = max(nums[i], nums[i - 1] + nums[i])
            return max(nums)
        def min_subarray_sum(nums):
            n = len(nums)
            for i in range(1, n):
                nums[i] = min(nums[i], nums[i - 1] + nums[i])
            return min(nums)
        total = sum(nums)
        if all([n < 0 for n in nums]):
            return max(nums)
        return max(max_subarray_sum(nums[::]), total - min_subarray_sum(nums[::]))
```

### 2321. Maximum Score Of Spliced Array

```python
class Solution:
    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:
        arr1 = [n1 - n2 for n1, n2 in zip(nums1, nums2)]
        arr2 = [n2 - n1 for n1, n2 in zip(nums1, nums2)]
        n = len(arr1)
        for i in range(1, n):
            arr1[i] = max(arr1[i], arr1[i - 1] + arr1[i])
            arr2[i] = max(arr2[i], arr2[i - 1] + arr2[i])
        return max(max(arr1) + sum(nums2), max(arr2) + sum(nums1))
```

### 152. Maximum Product Subarray

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = mx = mn = nums[0]
        n = len(nums)
        for i in range(1, n):
            temp = mx 
            mx = max(mx * nums[i], mn * nums[i], nums[i])
            mn = min(temp * nums[i], mn * nums[i], nums[i])
            res = max(res, mx)
        return res
```


### 62. Unique Paths

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        R, C = m, n
        dp = [[1] * C for i in range(R)]
        for r in range(1, m):
            for c in range(1, n):
                dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
        return dp[-1][-1]
```

### 63. Unique Paths II

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        R, C = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[1] * C for i in range(R)]
        if obstacleGrid[0][0] == 1: return 0
        for c in range(1, C):
            dp[0][c] = dp[0][c - 1] if obstacleGrid[0][c] != 1 else 0
        for r in range(1, R):
            dp[r][0] = dp[r - 1][0] if obstacleGrid[r][0] != 1 else 0
        for r in range(1, R):
            for c in range(1, C):
                dp[r][c] = dp[r - 1][c] + dp[r][c - 1] if obstacleGrid[r][c] != 1 else 0
        return dp[-1][-1]
```

### 64. Minimum Path Sum

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        for r in range(1, R):
            grid[r][0] += grid[r - 1][0]
        for c in range(1, C):
            grid[0][c] += grid[0][c - 1]
        for r in range(1, R):
            for c in range(1, C):
                grid[r][c] += min(grid[r - 1][c], grid[r][c - 1])
        return grid[-1][-1]
```

### 120. Triangle

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        for r in range(n - 2, -1, -1):
            for c in range(r + 1):
                triangle[r][c] += min(triangle[r + 1][c: c + 2])
        return triangle[0][0]
```

### 3393. Count Paths With the Given XOR Value

```python 
class Solution:
    def countPathsWithXorValue(self, grid: List[List[int]], k: int) -> int:
        R, C = len(grid), len(grid[0])
        mod = 10 ** 9 + 7 
        @cache
        def f(r, c, x):
            if r == R or c == C:
                return 0 
            x ^= grid[r][c]
            if r == R - 1 and c == C - 1:
                return 1 if x == k else 0
            return (f(r, c + 1, x) + f(r + 1, c, x)) % mod 
        return f(0, 0, 0)
```

### 931. Minimum Falling Path Sum

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        R, C = len(matrix), len(matrix[0]) + 2
        dp = [[inf] * C for i in range(R)]
        for c in range(1, C - 1):
            dp[0][c] = matrix[0][c - 1]
        for r in range(1, R):
            for c in range(1, C - 1):
                dp[r][c] = min(dp[r - 1][c - 1: c + 2]) + matrix[r][c - 1]
        return min(dp[-1])
```

### 2684. Maximum Number of Moves in a Grid

```python
class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        q = deque([(r, 0, 0) for r in range(R)])
        visited = set([(r, 0) for r in range(R)])
        
        while q:
            r, c, count = q.popleft()
            for row, col in [(r - 1, c + 1), (r, c + 1), (r + 1, c + 1)]:
                if 0 <= row < R and 0 <= col < C and (row, col) not in visited and grid[row][col] > grid[r][c]:
                    q.append((row, col, count + 1))
                    visited.add((row, col))
        return count
```

### 1289. Minimum Falling Path Sum II

```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        R, C = len(matrix), len(matrix[0])
        for r in range(1, R):
            for c in range(C):
                matrix[r][c] += min(matrix[r - 1][:c] + matrix[r - 1][c + 1:])
        return min(matrix[-1])
```

### 2304. Minimum Path Cost in a Grid

```python
class Solution:
    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])
        for r in range(R - 2, -1, -1):
            for c in range(C):
                grid[r][c] += min(n + c for n, c in zip(grid[r + 1], moveCost[grid[r][c]]))
        return min(grid[0])
```

### 3418. Maximum Amount of Money Robot Can Earn

```python
class Solution:
    def maximumAmount(self, coins: List[List[int]]) -> int:
        R, C = len(coins), len(coins[0])
        @cache
        def f(r, c, k):
            if r < 0 or c < 0:
                return -inf 
            x = coins[r][c]
            if r == 0 and c == 0:
                return max(x, 0) if k else x 
            res = max(f(r - 1, c, k), f(r, c - 1, k)) + coins[r][c]
            if k and x < 0:
                res = max(res, f(r - 1, c, k - 1), f(r, c - 1, k - 1))
            return res 
        return f(R - 1, C - 1, 2)
```

### 1594. Maximum Non Negative Product in a Matrix

```python
class Solution:
    def maxProductPath(self, grid: List[List[int]]) -> int:
        mod = 10 ** 9 + 7
        R, C = len(grid), len(grid[0])
        mx_grid, mn_grid = deepcopy(grid), deepcopy(grid)
        for c in range(1, C):
            mx_grid[0][c] = mn_grid[0][c] = mx_grid[0][c - 1] * grid[0][c]
        for r in range(1, R):
            mx_grid[r][0] = mn_grid[r][0] = mx_grid[r - 1][0] * grid[r][0]
        print(mx_grid, mn_grid)
        for r in range(1, R):
            for c in range(1, C):
                if grid[r][c] >= 0:
                    mx_grid[r][c] = max(mx_grid[r - 1][c], mx_grid[r][c - 1]) * grid[r][c]
                    mn_grid[r][c] = min(mn_grid[r - 1][c], mn_grid[r][c - 1]) * grid[r][c]
                else:
                    mx_grid[r][c] = min(mn_grid[r - 1][c], mn_grid[r][c - 1]) * grid[r][c]
                    mn_grid[r][c] = max(mx_grid[r - 1][c], mx_grid[r][c - 1]) * grid[r][c]
        return mx_grid[-1][-1] % mod if mx_grid[-1][-1] >= 0 else -1
```

### 1301. Number of Paths with Max Score

```python
class Solution:
    def pathsWithMaxScore(self, board: List[str]) -> List[int]:
        @cache
        def dfs(r, c):
            if r == c == n - 1:
                return [0, 1]
            res = [-inf, 0]
            for dr, dc in [[r + 1, c + 1], [r + 1, c], [r, c + 1]]:
                if 0 <= dr < n and 0 <= dc < n:
                    nxt = dfs(dr, dc)
                    if res[0] < nxt[0]:
                        res = nxt[:]
                    elif res[0] == nxt[0]:
                        res[1] = (res[1] + nxt[1]) % mod 
            res[0] += d[board[r][c]]
            return res 
        
        mod = 10 ** 9 + 7
        d = {str(i): i for i in range(10)}
        d['S'] = 0
        d['E'] = 0
        d['X'] = -inf 
        n = len(board)
        res = dfs(0, 0)
        return res if res[0] > -inf else [0, 0]
```

### 2435. Paths in Matrix Whose Sum Is Divisible by K

```python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        mod = 10 ** 9 + 7
        R, C = len(grid), len(grid[0])
        @cache
        def dfs(r, c, total):
            if r >= R or c >= C:
                return 0
            total = (total + grid[r][c]) % k
            if r == R - 1 and c == C - 1:
                return 1 if total % k == 0 else 0
            res = dfs(r + 1, c, total) + dfs(r, c + 1, total)
            return res % mod
        res = dfs(0, 0, 0)
        dfs.cache_clear()
        return res
```

### 174. Dungeon Game

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        @cache 
        def dfs(r, c, total):
            if r >= R or c >= C:
                return False 
            total += dungeon[r][c]
            if r == R - 1 and c == C - 1:
                return True if total > 0 else False 
            if total > 0:
                return dfs(r + 1, c, total) or dfs(r, c + 1, total)

        R, C = len(dungeon), len(dungeon[0])
        l, r, res = 1, 4 * 10 ** 7, 1
        while l <= r:
            m = l + (r - l) // 2 
            if dfs(0, 0, m):
                res = m 
                r = m - 1
            else:
                l = m + 1
        return res 
```

### 329. Longest Increasing Path in a Matrix

```python 
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        @cache
        def dfs(r, c):
            res = 1
            for dr, dc in directions:
                row, col = r + dr, c + dc 
                if 0 <= row < R and 0 <= col < C and matrix[r][c] < matrix[row][col]:
                    res = max(res, dfs(row, col) + 1)
            return res 
        R, C = len(matrix), len(matrix[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        res = 1
        for r in range(R):
            for c in range(C):
                res = max(res, dfs(r, c))
        return res
```

### 2328. Number of Increasing Paths in a Grid

```python
class Solution:
    def countPaths(self, matrix: List[List[int]]) -> int:
        R, C, res = len(matrix), len(matrix[0]), 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        mod = 10 ** 9 + 7
        @cache
        def dfs(r, c):
            res = 1
            for dr, dc in directions:
                row, col = r + dr, c + dc 
                if 0 <= row < R and 0 <= col < C and matrix[r][c] < matrix[row][col]:
                    res += dfs(row, col)
            return res 
            
        for r in range(R):
            for c in range(C):
                res += dfs(r, c)
        return res % mod 
```

### 329. Longest Increasing Path in a Matrix

```python
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        @cache
        def dfs(r, c):
            res = 0
            for dr, dc in directions:
                row, col = r + dr, c + dc 
                if 0 <= row < R and 0 <= col < C and matrix[r][c] < matrix[row][col]:
                    res = max(res, dfs(row, col) + 1)
            return res 
        R, C = len(matrix), len(matrix[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        res = 0
        for r in range(R):
            for c in range(C):
                res = max(res, dfs(r, c))
        return res + 1
```

```python
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        R, C = len(matrix), len(matrix[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        indegree = [0] * R * C 

        for r in range(R):
            for c in range(C):
                for dr, dc in directions:
                    row, col = r + dr, c + dc 
                    if 0 <= row < R and 0 <= col < C and matrix[r][c] < matrix[row][col]:
                        indegree[row * C + col] += 1

        res, q = 0, deque([i for i, d in enumerate(indegree) if d == 0])
        while q:
            for i in range(len(q)):
                node = q.popleft()
                r, c = node // C,  node % C
                for dr, dc in directions:
                    row, col = r + dr, c + dc 
                    if 0 <= row < R and 0 <= col < C and matrix[r][c] < matrix[row][col]:
                        indegree[row * C + col] -= 1
                        if indegree[row * C + col] == 0:
                            q.append(row * C + col)
            res += 1
        return res
```

### 2267. Check if There Is a Valid Parentheses String Path

```python
class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
        @cache
        def dfs(r, c, open, close):
            if r >= R or c >= C or open < close:
                return False 
            if r == R - 1 and c == C - 1 and grid[r][c] == ')':
                return True if open == close + 1 else False 
            if grid[r][c] == '(':
                return dfs(r + 1, c, open + 1, close) or dfs(r, c + 1, open + 1, close)
            else:
                return dfs(r + 1, c, open, close + 1) or dfs(r, c + 1, open, close + 1)
        
        R, C = len(grid), len(grid[0])
        res = dfs(0, 0, 0, 0)
        dfs.cache_clear()
        return res
```


### 2510. Check if There is a Path With Equal Number of 0's And 1's

- same as 2267. Check if There Is a Valid Parentheses String Path

```python
class Solution:
    def isThereAPath(self, grid: List[List[int]]) -> bool:
        @cache
        def dfs(r, c, one, zero):
            if r >= R or c >= C or one > (R + C) / 2 or zero > (R + C) / 2:
                return False 
            if r == R - 1 and c == C - 1:
                if grid[r][c] == 1:
                    return True if one + 1 == zero else False 
                else:
                    return True if one == zero + 1 else False 
            if grid[r][c] == 1:
                return dfs(r + 1, c, one + 1, zero) or dfs(r, c + 1, one + 1, zero)
            else:
                return dfs(r + 1, c, one, zero + 1) or dfs(r, c + 1, one, zero + 1)

        R, C = len(grid), len(grid[0])
        res = dfs(0, 0, 0, 0)
        dfs.cache_clear()
        return res
```

### 1937. Maximum Number of Points with Cost

```python
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        R, C = len(points), len(points[0])
        dp = deepcopy(points)
        for r in range(1, R):
            preMax, sufMax = -inf, -inf
            for c in range(C):
                preMax = max(preMax, dp[r - 1][c] + c)
                dp[r][c] = max(dp[r][c], points[r][c] - c + preMax)
            for c in range(C - 1, -1, -1):
                sufMax = max(sufMax, dp[r - 1][c] - c)
                dp[r][c] = max(dp[r][c], points[r][c] + c + sufMax)
        return max(dp[-1])
# points[r][c] = points[r][c] + max(points[r - 1][k] + k - c) k <= c
# points[r][c] = points[r][c] + max(points[r - 1][k] - k + c) k >= c

# points[r][c] = points[r][c] - c + max(points[r - 1][k] + k) k <= c
# points[r][c] = points[r][c] + c + max(points[r - 1][k] - k) k >= c
```

### 1463. Cherry Pickup II

```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        @cache 
        def dfs(r, c1, c2):
            if r >= R or c1 < 0 or c1 >= C or c2 < 0 or c2 >= C:
                return -inf 
            cur = grid[r][c1] if c1 == c2 else grid[r][c1] + grid[r][c2]
            if r == R - 1:
                return cur
            res = -inf 
            for dr1, dc1 in directions:
                row1, col1 = r + dr1, c1 + dc1 
                for dr2, dc2 in directions:
                    row2, col2 = r + dr2, c2 + dc2 
                    res = max(res, dfs(row1, col1, col2))
            return res + cur
        R, C = len(grid), len(grid[0])
        directions = [[1, 0], [1, -1], [1, 1]]
        return dfs(0, 0, C - 1)
```

### 741. Cherry Pickup

```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        @cache 
        def dfs(r1, c1, r2): # c2 == r1 + c1 - r2
            if any(item >= n for item in [r1, c1, r2, r1 + c1 - r2]) or grid[r1][c1] == -1 or grid[r2][r1 + c1 - r2] == -1:
                return -inf 
            cur = grid[r1][c1] if c1 == r1 + c1 - r2 else grid[r1][c1] + grid[r2][r1 + c1 - r2]
            if r1 == n - 1 and c1 == n - 1:
                return cur
            res = -inf 
            for dr1, dc1 in directions:
                row1, col1 = r1 + dr1, c1 + dc1 
                for dr2, dc2 in directions:
                    row2, col2 = r2 + dr2, r1 + c1 - r2 + dc2 
                    res = max(res, dfs(row1, col1, row2))
            return res + cur
        n = len(grid)
        directions = [[1, 0], [0, 1]]
        res = dfs(0, 0, 0)
        return res if res != -inf else 0
```

### 1824. Minimum Sideway Jumps

```python
class Solution:
    def minSideJumps(self, obstacles: List[int]) -> int:
        f = [1, 0, 1]
        for o in obstacles[1:]:
            for j in range(3):
                if o == j + 1:
                    f[j] = inf 
                    break
            x = min(f) + 1
            for j in range(3):
                if o != j + 1:
                    f[j] = min(f[j], x)
        return min(f)
```

### 3363. Find the Maximum Number of Fruits Collected

```python
class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        @cache
        def dfs(i, j):
            if not (n - 1 - i <= j < n):
                return -inf
            if i == 0:
                return fruits[i][j]
            return max(dfs(i - 1, j - 1), dfs(i - 1, j), dfs(i - 1, j + 1)) + fruits[i][j]

        ans = sum(row[i] for i, row in enumerate(fruits))
        ans += dfs(n - 2, n - 1) 
        dfs.cache_clear()
        fruits = list(zip(*fruits))
        return ans + dfs(n - 2, n - 1)
```

### 3459. Length of Longest V-Shaped Diagonal Segment

```python
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        directions = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        R, C = len(grid), len(grid[0])
        @cache 
        def dfs(r, c, k, can_turn, target):
            r += directions[k][0]
            c += directions[k][1]
            if not (0 <= r < R and 0 <= c < C) or grid[r][c] != target:
                return 0
            res = dfs(r, c, k, can_turn, 2 - target)
            if can_turn:
                res = max(res, dfs(r, c, (k + 1) % 4, False, 2 - target))
            return res + 1

        res = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 1:
                    for k in range(4):
                        res = max(res, dfs(i, j, k, True, 2) + 1)
        return res  
```


### 2915. Length of the Longest Subsequence That Sums to Target

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        nums.sort(reverse = True)
        N = len(nums)
        @cache
        def f(t, i):
            if t > target:
                return -inf
            if i == N:
                return 0 if t == target else -inf 
            return max(f(t, i + 1), f(t + nums[i], i + 1) + 1)
        res = f(0, 0)
        f.cache_clear()
        return res if res != -inf else -1
```


### 416. Partition Equal Subset Sum

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        total = sum(nums)
        if total % 2:
            return False 
        total //= 2
        @cache
        def dfs(i, t):
            if i == n:
                return True if t == total else False 
            return dfs(i + 1, t) or dfs(i + 1, t + nums[i])
        return dfs(0, 0)
```

### 494. Target Sum

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        n = len(nums)
        @cache
        def dfs(i, t):
            if i == n:
                return 1 if t == target else 0
            return dfs(i + 1, t - nums[i]) + dfs(i + 1, t + nums[i])
        return dfs(0, 0)
```

### 2787. Ways to Express an Integer as Sum of Powers

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        nums = list(range(1, n + 1))[::-1]
        mod = 10 ** 9 + 7
        @cache 
        def dfs(i, t):
            if t > n:
                return 0 
            if i == n:
                return 1 if t == n else 0 
            return (dfs(i + 1, t) + dfs(i + 1, t + nums[i] ** x)) % mod 
        return dfs(0, 0)
```

### 3180. Maximum Total Reward Using Operations I

```python
rewardValues.sort()
        n = len(rewardValues)
        @cache
        def dfs(i, t):
            if i == n:
                return t
            res = dfs(i + 1, t)
            if rewardValues[i] > t:
                res = max(res, dfs(i + 1, t + rewardValues[i]))
            return res
        res = dfs(0, 0)
        dfs.cache_clear()
        return res
```

### 474. Ones and Zeroes (multi knapsacks)

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        @cache
        def f(a, b, i):
            if i == len(strs):
                return 0 if (a <= m and b <= n) else -inf
            if a > m or b > n: # optimize
                return -inf
            ones, zeros = strs[i].count('1'), strs[i].count('0')
            return max(f(a, b, i + 1), f(a + zeros, b + ones, i + 1) + 1)
        res = f(0, 0, 0)
        return res if res != -inf else 0
```

### 1049. Last Stone Weight II

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        mx = max(stones)
        @cache
        def f(t, i):
            if i == len(stones):
                return abs(t)
            if t > mx: # optimize
                return inf
            return min(f(t - stones[i], i + 1), f(t + stones[i], i + 1))
        return f(0, 0)
```

### 2291. Maximum Profit From Trading Stocks

```python
class Solution:
    def maximumProfit(self, present: List[int], future: List[int], budget: int) -> int:
        @cache
        def dfs(i, b):
            if b > budget:
                return -inf 
            if i == n:
                return 0 if b <= budget else -inf 
            res = dfs(i + 1, b)
            if future[i] > present[i]:
                res = max(res, dfs(i + 1, b + present[i]) + future[i] - present[i])
            return res 

        n = len(present)
        res = dfs(0, 0)
        dfs.cache_clear()
        return res if res != -inf else 0
```

### 3082. Find the Sum of the Power of All Subsequences

```python
class Solution:
    def sumOfPower(self, nums: List[int], k: int) -> int:
        @cache
        def dfs(i, t, selected):
            if t > k:
                return 0
            if i == n:
                return 2 ** (n - selected) if t == k else 0 
            return dfs(i + 1, t, selected) + dfs(i + 1, t + nums[i], selected + 1)
        
        n = len(nums)
        mod = 10 ** 9 + 7
        res = dfs(0, 0, 0)
        dfs.cache_clear()
        return res % mod
```

### 1774. Closest Dessert Cost

```python
class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:
        def dfs(i, cost):
            if i == len(toppingCosts):
                if abs(cost - target) < abs(self.res - target) or (abs(cost - target) == abs(self.res - target) and cost < target):
                    self.res = cost 
                return

            dfs(i + 1, cost)
            dfs(i + 1, cost + toppingCosts[i])
            dfs(i + 1, cost + toppingCosts[i] * 2)
        
        self.res = inf 
        for base in baseCosts:
            dfs(0, base)
        return self.res 
```

### 879. Profitable Schemes (multi dimentional)

```python
mod = 10 ** 9 + 7

class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        res = []
        for g, p in zip(group, profit):
            res.append(((g / p) if p != 0 else inf, g, p))
        res.sort(reverse = True)
        group, profit = [item[1] for item in res], [item[2] for item in res]
        N = len(group)
        @cache
        def f(p, g, i):
            if g > n:
                return 0
            if i == N:
                return 1 if p >= minProfit else 0
            return f(p, g, i + 1) + f(p + profit[i], g + group[i], i + 1)
        return f(0, 0, 0) % mod
```



### 805. Split Array With Same Average

```python
class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        nums.sort()
        total, N = sum(nums), len(nums)
        average = total / N
        # total / N = t / n, t is integer
        if all(total * i % N != 0 for i in range(1, N // 2 + 1)):
            return False
        @cache
        def f(t, n, i):
            if t > n * average:
                return False
            if n and n < N and t / n == average:
                return True
            if i == N:
                if n == 0 or n == N:
                    return False
                return True if t * N == total * n else False
            return f(t, n, i + 1) or f(t + nums[i], n + 1, i + 1)
        return f(0, 0, 0)
```


### 923. 3Sum With Multiplicity

```python
class Solution:
    def threeSumMulti(self, arr: List[int], target: int) -> int:
        arr.sort(reverse = True)
        n = len(arr)
        mod = 10 ** 9 + 7
        @cache
        def dfs(i, total, count):
            if i >= n:
                return 1 if total == target and count == 3 else 0
            if total > target or count > 3:
                return 0
            return dfs(i + 1, total, count) + dfs(i + 1, total + arr[i], count + 1)
        return dfs(0, 0, 0) % mod

```

### 279. Perfect Squares

```python
square = [i * i for i in range(100, 0, -1)]
class Solution:
    def numSquares(self, n: int) -> int:
        @cache
        def f(t, i):
            if t > n:
                return inf 
            if i == len(square):
                return 0 if t == n else inf
            return min(f(t, i + 1), f(t + square[i], i) + 1) 
        res = f(0, 0)
        f.cache_clear()
        return res
```

### 322. Coin Change

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        coins.sort(reverse = True)
        @cache
        def f(t, i):
            if t > amount:
                return inf 
            if i == len(coins):
                return 0 if t == amount else inf 
            return min(f(t, i + 1), f(t + coins[i], i) + 1) 
        res = f(0, 0)
        return res if res != inf else -1
```

### 518. Coin Change II

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        coins.sort(reverse = True)
        N = len(coins)
        @cache
        def f(t, i):
            if t > amount:
                return 0
            if i == N:
                return 1 if t == amount else 0
            return f(t, i + 1) + f(t + coins[i], i)
        res = f(0, 0)
        return res if res != inf else -1
```

### 377. Combination Sum IV (unbounded knapsack with sequence)

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache
        def f(t):
            if t > target:
                return 0
            if t == target:
                return 1
            return sum(f(t + n) for n in nums)
        return f(0)
```

### 1449. Form Largest Integer With Digits That Add up to Target

```python
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        @cache
        def dfs(t):
            if t == 0:
                return ""
            ans = "0"
            for c in cost:
                if t >= c:
                    res = dfs(t - c)
                    if res != '0':
                        if len(res) + 1 > len(ans):
                            ans = d[c] + res
                        elif len(res) + 1 == len(ans):
                            ans = max(ans, d[c] + res, key = int)
            return ans

        d = dict((c, str(i)) for i, c in enumerate(cost, 1))
        cost = sorted(d.keys())
        return dfs(target)
```

### 3183. The Number of Ways to Make the Sum

```python
class Solution:
    def numberOfWays(self, n: int) -> int:
        mod = 10**9 + 7
        coins = [1, 2, 6]
        f = [0] * (n + 1)
        f[0] = 1
        for x in coins:
            for j in range(x, n + 1):
                f[j] = (f[j] + f[j - x]) % mod
        ans = f[n]
        if n >= 4:
            ans = (ans + f[n - 4]) % mod
        if n >= 8:
            ans = (ans + f[n - 8]) % mod
        return ans
```

### 2585. Number of Ways to Earn Points

```python
mod = 10 ** 9 + 7
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        n = len(types)
        @cache
        def f(i, t):
            if i < 0:
                return 1 if t == 0 else 0
            count, mark = types[i]
            res = 0
            for k in range(min(count, t // mark) + 1):
                res += f(i - 1, t - k * mark)
            return res
        return f(n - 1, target) % mod
```

### 2915. Length of the Longest Subsequence That Sums to Target

```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        nums.sort()
        N = len(nums)
        @cache
        def f(t, i):
            if t > target:
                return -inf 
            if i == N:
                return 0 if t == target else -inf 
            return max(f(t, i + 1), f(t + nums[i], i + 1) + 1)
        res = f(0, 0)
        f.cache_clear()
        return res if res != -inf else -1
```

### 416. Partition Equal Subset Sum

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:
            return False
        half = sum(nums) // 2
        @cache
        def f(t, i):
            if i == len(nums):
                return True if t == half else False
            return f(t, i + 1) or f(t + nums[i], i + 1)
        return f(0, 0)
```

### 494. Target Sum

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        @cache
        def f(t, i):
            if i == len(nums):
                return 1 if t == target else 0
            return f(t - nums[i], i + 1) + f(t + nums[i], i + 1)
        return f(0, 0)
```


### 474. Ones and Zeroes

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        @cache
        def f(a, b, i):
            if i == len(strs):
                return 0 if (a <= m and b <= n) else -inf
            if a > m or b > n:
                return -inf
            ones, zeros = strs[i].count('1'), strs[i].count('0')
            return max(f(a, b, i + 1), f(a + zeros, b + ones, i + 1) + 1)
        res = f(0, 0, 0)
        return res if res != -inf else 0
```



### 1049. Last Stone Weight II

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        mx = max(stones)
        @cache
        def f(t, i):
            if i == len(stones):
                return abs(t)
            if t > mx:  # optimize
                return inf
            return min(f(t - stones[i], i + 1), f(t + stones[i], i + 1))

        return f(0, 0)
```

### 279. Perfect Squares

```python
square = [i * i for i in range(100, 0, -1)]
class Solution:
    def numSquares(self, n: int) -> int:
        @cache
        def f(t, i):
            if t > n:
                return inf 
            if i == len(square):
                return 0 if t == n else inf
            return min(f(t, i + 1), f(t + square[i], i) + 1) 
        res = f(0, 0)
        f.cache_clear()
        return res
```

### 1449. Form Largest Integer With Digits That Add up to Target

### 2585. Number of Ways to Earn Points

```python
mod = 10 ** 9 + 7
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        n = len(types)
        @cache
        def f(i, t):
            if i < 0:
                return 1 if t == 0 else 0
            count, mark = types[i]
            res = 0
            for k in range(min(count, t // mark) + 1):
                res += f(i - 1, t - k * mark)
            return res
        return f(n - 1, target) % mod
```

### 1155. Number of Dice Rolls With Target Sum

```python
class Solution:
    def numRollsToTarget(self, n: int, k: int, target: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def dfs(i, t):
            if t > target:
                return 0
            if i == n:
                return 1 if t == target else 0
            res = 0
            for j in range(1, k + 1):
                res += dfs(i + 1, t + j)
            return res % mod
        return dfs(0, 0) % mod
```

### 1981. Minimize the Difference Between Target and Chosen Elements

```python
class Solution:
    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:
        # R, C = len(mat), len(mat[0])
        # self.res = inf 
        # @cache
        # def dfs(r, t):
        #     if r == R:
        #         self.res = min(self.res, abs(t - target))
        #         return
        #     for c in range(C):
        #         dfs(r + 1, t + mat[r][c])
        # dfs(0, 0)
        # return self.res
        @cache
        def f(i):
            if i == 0:
                return set(mat[0])
            return set(x + y for x in mat[i] for y in f(i - 1))
        R = len(mat)
        return min(abs(target - v) for v in f(R - 1))
```

### 2218. Maximum Value of K Coins From Piles

```python
class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:
        n = len(piles)
        @cache
        def f(i, k):
            if i == n or k == 0:
                return 0
            res = f(i + 1, k)
            pre = 0
            for j in range(min(k, len(piles[i]))):
                pre += piles[i][j]
                res = max(res, f(i + 1, k - j - 1) + pre)
            return res 
        return f(0, k)
```


### 1143. Longest Common Subsequence

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        @cache
        def f(i, j):
            if i < 0 or j < 0:
                return 0
            if text1[i] == text2[j]:
                return f(i - 1, j - 1) + 1
            return max(f(i - 1, j), f(i, j - 1))
        R, C = len(text1), len(text2)
        return f(R - 1, C - 1)

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        def lcs(s1, s2):
            R, C = len(s1) + 1, len(s2) + 1
            f = [[0] * C for i in range(R)]
            for i in range(1, R):
                for j in range(1, C):
                    if s1[i - 1] == s2[j - 1]:
                        f[i][j] = 1 + f[i - 1][j - 1]
                    else:
                        f[i][j] = max(f[i][j - 1], f[i - 1][j])
            return f[-1][-1]
        return lcs(text1, text2)
```

### 583. Delete Operation for Two Strings

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        def lcs(s1, s2):
            R, C = len(s1) + 1, len(s2) + 1
            f = [[0] * C for i in range(R)]
            for i in range(1, R):
                for j in range(1, C):
                    if s1[i - 1] == s2[j - 1]:
                        f[i][j] = 1 + f[i - 1][j - 1]
                    else:
                        f[i][j] = max(f[i][j - 1], f[i - 1][j])
            return f[-1][-1]
        return len(word1) + len(word2) - 2 * lcs(word1, word2)
```


### 712. Minimum ASCII Delete Sum for Two Strings

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def f(i, j):
            if i < 0 or j < 0:
                if i < 0 and j < 0:
                    return 0
                return i + 1 if j < 0 else j + 1
            if word1[i] == word2[j]:
                return f(i - 1, j - 1)
            return min(f(i - 1, j), f(i, j - 1), f(i - 1, j - 1)) + 1
        R, C = len(word1), len(word2)
        return f(R - 1, C - 1)

class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        R, C = len(s1) + 1, len(s2) + 1
        dp = [[0] * C for r in range(R)]
        for c in range(1, C):
            dp[0][c] += ord(s2[c - 1]) + dp[0][c - 1]
        for r in range(1, R):
            dp[r][0] += ord(s1[r - 1]) + dp[r - 1][0]
            
        for r in range(1, R):
            for c in range(1, C):
                if s1[r - 1] == s2[c - 1]:
                    dp[r][c] = dp[r - 1][c - 1]
                else:
                    dp[r][c] = min(dp[r - 1][c] + ord(s1[r - 1]), dp[r][c - 1] + ord(s2[c - 1]))
        return dp[-1][-1]
```

### 72. Edit Distance

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        R, C = len(word1) + 1, len(word2) + 1
        dp = [[0] * C for r in range(R)]
        for c in range(1, C):
            dp[0][c] = dp[0][c - 1] + 1
        for r in range(1, R):
            dp[r][0] = dp[r - 1][0] + 1
        for r in range(1, R):
            for c in range(1, C):
                if word1[r - 1] == word2[c - 1]:
                    dp[r][c] = dp[r - 1][c - 1]
                else:
                    dp[r][c] = min(dp[r][c - 1], dp[r - 1][c], dp[r - 1][c - 1]) + 1
        return dp[-1][-1]
```

### 97. Interleaving String

```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        R, C = len(s1) + 1, len(s2) + 1
        if R + C - 2 != len(s3):
            return False
        dp = [[False] * C for r in range(R)]
        dp[0][0] = True
        for r in range(1, R):
            dp[r][0] = dp[r - 1][0] and (s1[r - 1] == s3[r - 1])
        for c in range(1, C):
            dp[0][c] = dp[0][c - 1] and (s2[c - 1] == s3[c - 1])
        for r in range(1, R):
            for c in range(1, C):
                dp[r][c] = (dp[r][c - 1] and s3[r + c - 1] == s2[c - 1]) or (dp[r - 1][c] and s3[r + c - 1] == s1[r - 1])
        return dp[-1][-1]
```

### 115. Distinct Subsequences

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        @cache
        def f(i, j):
            if i < 0 or j < 0:
                if j < 0:
                    return 1
                return 0
            if s[i] == t[j]:
                return f(i - 1, j - 1) + f(i - 1, j)
            return f(i - 1, j)
        R, C = len(s), len(t)
        return f(R - 1, C - 1)

class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        R, C = len(s) + 1, len(t) + 1
        dp = [[0] * C for r in range(R)]
        for r in range(R):
            dp[r][0] = 1
        for c in range(1, C):
            for r in range(c, R):
                if s[r - 1] == t[c - 1]:
                    dp[r][c] = dp[r - 1][c - 1] + dp[r - 1][c]
                else:
                    dp[r][c] = dp[r - 1][c]
        return dp[-1][-1]
```

### 1035. Uncrossed Lines

```python
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        @cache
        def f(i, j):
            if i < 0 or j < 0:
                return 0
            if nums1[i] == nums2[j]:
                return f(i - 1, j - 1) + 1
            return max(f(i - 1, j), f(i, j - 1))
        R, C = len(nums1), len(nums2)
        return f(R - 1, C - 1)

class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        def lcs(s1, s2):
            R, C = len(s1) + 1, len(s2) + 1
            f = [[0] * C for i in range(R)]
            for i in range(1, R):
                for j in range(1, C):
                    if s1[i - 1] == s2[j - 1]:
                        f[i][j] = 1 + f[i - 1][j - 1]
                    else:
                        f[i][j] = max(f[i][j - 1], f[i - 1][j])
            return f[-1][-1]
        return lcs(nums1, nums2)
```

### 1458. Max Dot Product of Two Subsequences

```python
class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        @cache
        def f(i, j):
            if i < 0 or j < 0:
                return -inf
            return max(f(i - 1, j), f(i, j - 1), nums1[i] * nums2[j], f(i - 1, j - 1) + nums1[i] * nums2[j])
        R, C = len(nums1), len(nums2)
        res = f(R - 1, C - 1)
        return res

class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        R, C = len(nums1) + 1, len(nums2) + 1
        f = [[-inf] * C for r in range(R)]
        for r in range(1, R):
            for c in range(1, C):
                f[r][c] = max(f[r - 1][c], f[r][c - 1], f[r - 1][c - 1] + nums1[r - 1] * nums2[c - 1], nums1[r - 1] * nums2[c - 1])
        return f[-1][-1]
```

### 1092. Shortest Common Supersequence 

```python
class Solution:
    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:
        R, C = len(str1) + 1, len(str2) + 1
        f = [[0] * C for r in range(R)]
        for r in range(1, R):
            f[r][0] += f[r - 1][0] + 1
        for c in range(1, C):
            f[0][c] += f[0][c - 1] + 1
        for r in range(1, R):
            for c in range(1, C):
                if str1[r - 1] != str2[c - 1]:
                    f[r][c] = min(f[r - 1][c] + 1, f[r][c - 1] + 1)
                else:
                    f[r][c] = f[r - 1][c - 1] + 1
        
        res = []
        r, c = R - 1, C - 1
        while r >= 1 and c >= 1:
            if str1[r - 1] == str2[c - 1]:
                res.append(str1[r - 1])
                r -= 1
                c -= 1
            elif f[r][c] == f[r - 1][c] + 1:
                res.append(str1[r - 1])
                r -= 1
            else:
                res.append(str2[c - 1])
                c -= 1
        return str1[: r] + str2[: c] + ''.join(reversed(res))
```

### 1639. Number of Ways to Form a Target String Given a Dictionary

```python
n = len(words[0])
        m = len(target)
        mod = 10 ** 9 + 7
        dp = [[0] * 26 for i in range(n)]
        for i, w in enumerate(words):
            for j, c in enumerate(w):
                dp[j][ord(w[j]) - ord('a')] += 1
        
        @cache
        def dfs(i, j):
            if j == m:
                return 1
            if i == n:
                return 0
            return dfs(i + 1, j + 1) * dp[i][ord(target[j]) - ord('a')] + dfs(i + 1, j)
        return dfs(0, 0) % mod
```

### 161. One Edit Distance

Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.

A string s is said to be one distance apart from a string t if you can:

Insert exactly one character into s to get t.
Delete exactly one character from s to get t.
Replace exactly one character of s with a different character to get t.
 
Example 1:

Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.

Example 2:

Input: s = "", t = ""
Output: false
Explanation: We cannot get t from s by only one step.
 
Constraints:

0 <= s.length, t.length <= 104
s and t consist of lowercase letters, uppercase letters, and digits.

### 161. One Edit Distance

```python
class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        ns, nt = len(s), len(t)
        if ns > nt:
            return self.isOneEditDistance(t, s)
        if nt - ns > 1:
            return False

        for i in range(ns):
            if s[i] != t[i]:
                if ns == nt:
                    return s[i + 1:] == t[i + 1:]
                else:
                    return s[i:] == t[i + 1:]
        return ns + 1 == nt
```

### 516. Longest Palindromic Subsequence

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        def LCS(text1, text2):
            R, C = len(text1) + 1, len(text2) + 1
            dp = [[0] * C for i in range(R)]
            for i in range(1, R):
                for j in range(1, C):
                    if text1[i - 1] == text2[j - 1]:
                        dp[i][j] = 1 + dp[i - 1][j - 1]
                    else:
                        dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
            return dp[-1][-1]
        return LCS(s, s[::-1])
```

### 1312. Minimum Insertion Steps to Make a String Palindrome

```python
class Solution:
    def minInsertions(self, s: str) -> int:
        def LCS(text1, text2):
            R, C = len(text1) + 1, len(text2) + 1
            dp = [[0] * C for i in range(R)]
            for i in range(1, R):
                for j in range(1, C):
                    if text1[i - 1] == text2[j - 1]:
                        dp[i][j] = 1 + dp[i - 1][j - 1]
                    else:
                        dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
            return dp[-1][-1]
        return len(s) - LCS(s, s[::-1])
```

### 44. Wildcard Matching

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        R, C = len(s) + 1, len(p) + 1
        dp = [[False] * C for r in range(R)]
        dp[0][0] = True
        for c in range(1, C):
            if p[c - 1] != '*': 
                break
            dp[0][c] = True
        for r in range(1, R):
            for c in range(1, C):
                if p[c - 1] == '?' or p[c - 1] == s[r - 1]:
                    dp[r][c] = dp[r - 1][c - 1]
                elif p[c - 1] == '*':
                    dp[r][c] = dp[r][c - 1] or dp[r - 1][c]
        return dp[-1][-1]
```

### 10. Regular Expression Matching

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        R, C = len(s) + 1, len(p) + 1
        dp = [[False] * C for r in range(R)]
        dp[0][0] = True
        for c in range(2, C):
            dp[0][c] = dp[0][c - 2] and p[c - 1] == '*'
        for r in range(1, R):
            for c in range(1, C):
                if p[c - 1] == '.' or p[c - 1] == s[r - 1]:
                    dp[r][c] = dp[r - 1][c - 1]
                elif p[c - 1] == '*':
                    zero = dp[r][c - 2]
                    many = dp[r - 1][c] and (p[c - 2] == '.' or p[c - 2] == s[r - 1])
                    dp[r][c] = zero or many 
        return dp[-1][-1]
```

### 300. Longest Increasing Subsequence

- binary search: O(nlog(n))

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def lis(nums):
            f = []
            for n in nums:
                i = bisect_left(f, n)
                if i == len(f):
                    f.append(n)
                else:
                    f[i] = n 
            return len(f)
        return lis(nums)
```

- O(n^2)

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        f = [1] * n 
        for i in range(1, n):
            for j in range(i):
                if nums[j] < nums[i]:
                    f[i] = max(f[i], f[j] + 1)
        return max(f)
```


### 334. Increasing Triplet Subsequence

- binary search 

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        f = []
        for n in nums:
            i = bisect_left(f, n)
            if i == len(f):
                f.append(n)
            else:
                f[i] = n 
        return len(f) >= 3
```

- math

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        f = [inf] * 3
        for i, v in enumerate(nums):
            if v < f[1]:
                f[1] = v 
            elif f[1] < v < f[2]:
                f[2] = v 
            elif v > f[2]:
                return True
        return False
```

### 646. Maximum Length of Pair Chain

```python
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        n = len(pairs)
        f = [1] * n 
        pairs.sort()
        for i in range(n):
            for j in range(i):
                if pairs[j][1] < pairs[i][0]:
                    f[i] = max(f[i], f[j] + 1)
        return max(f)
```

```python
class Solution:
    def findLongestChain(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        n = len(intervals)
        def LIS(arr): # strictly increasing
            LIS = []
            for x, y in arr:
                i = bisect_left(LIS, x)
                if i == len(LIS):
                    LIS.append(y)
                else:
                    LIS[i] = min(LIS[i], y) # insert need to check min y
            return len(LIS) 
        return LIS(intervals)
```

### 673. Number of Longest Increasing Subsequence

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        count = [1] + [0] * (n - 1)
        for r in range(1, n):
            for l in range(r):
                if nums[r] > nums[l]:
                    dp[r] = max(dp[r], dp[l] + 1)
            for l in range(r):
                if nums[r] > nums[l] and dp[l] == dp[r] - 1:
                    count[r] += count[l]
            if not count[r]:
                count[r] = 1

        mx = max(dp)
        return sum(count[i] for i, n in enumerate(dp) if n == mx)
```

### 2826. Sorting Three Groups

```python
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        N = len(nums)
        f = []
        for n in nums:
            i = bisect_right(f, n)
            if i == len(f):
                f.append(n)
            else:
                f[i] = n 
        return N - len(f)

# O(n)

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        f = [0] * 4
        for n in nums:
            f[n] = max(f[1: n + 1]) + 1
        return len(nums) - max(f)
```

### 1671. Minimum Number of Removals to Make Mountain Array

```python
class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        def LIS(nums):
            f = []
            for n in nums:
                i = bisect_left(f, n)
                if i == len(f):
                    f.append(n)
                else:
                    f[i] = n 
            return len(f)

        res, n = inf, len(nums)
        for i in range(1, n - 1):
            a, b = LIS(nums[:i + 1]), LIS(nums[i:][::-1])
            if a > 1 and b > 1:
                res = min(res, i + 1 - a + (n - i + 1) - b - 1)
        return res  
```

### 1964. Find the Longest Valid Obstacle Course at Each Position

```python
class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        LIS, res = [], []
        for x in obstacles:
            i = bisect_right(LIS, x)
            if i == len(LIS):
                LIS.append(x)
            else:
                LIS[i] = x
            res.append(i + 1)
        return res
```

### 1626. Best Team With No Conflicts

```python
class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        a = sorted(zip(scores, ages))
        f = [0] * len(a)
        for i, (score, age) in enumerate(a):
            for j in range(i):
                if a[j][1] <= age:
                    f[i] = max(f[i], f[j])
            f[i] += score
        return max(f)
```

### 354. Russian Doll Envelopes

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key = lambda x: [x[0], -x[1]])
        def LIS(arr): # strictly increasing
            LIS = []
            for n in arr:
                i = bisect_left(LIS, n)
                if i == len(LIS):
                    LIS.append(n)
                else:
                    LIS[i] = n
            return len(LIS)  
        res = [b for a, b in envelopes] 
        return LIS(res)
```

### 1691. Maximum Height by Stacking Cuboids 

```python
class Solution:
    def maxHeight(self, cuboids: List[List[int]]) -> int:
        for c in cuboids:
            c.sort()
        cuboids.sort()
        f = [0] * len(cuboids)
        for i, (w1, l1, h1) in enumerate(cuboids):
            for j, (w2, l2, h2) in enumerate(cuboids[:i]):
                if l2 <= l1 and h2 <= h1:
                    f[i] = max(f[i], f[j])
            f[i] += h1 
        return max(f)
```


### 2111. Minimum Operations to Make the Array K-Increasing

```python
class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        def lis(nums):
            f = []
            for n in nums:
                i = bisect_right(f, n)
                if i == len(f):
                    f.append(n)
                else:
                    f[i] = n 
            return len(f)

        res = 0
        for i in range(k):
            nums = arr[i::k]
            res += len(nums) - lis(nums)
        return res
```

### 3489. Zero Array Transformation IV

```python
class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n, m, res = len(nums), len(queries), -inf
        for i, x in enumerate(nums):
            a = [v if l <= i <= r else 0 for l, r, v in queries]
            @cache
            def f(k, x):
                if x == 0:
                    return k
                if x < 0 or k == m:
                    return inf 
                return min(f(k + 1, x), f(k + 1, x - a[k]))
            res = max(res, f(0, x))
        return res if res != inf else -1
```

### 718. Maximum Length of Repeated Subarray

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        R, C = len(nums1) + 1, len(nums2) + 1
        dp = [[0] * C for r in range(R)]
        res = 0
        for r in range(1, R):
            for c in range(1, C):
                if nums1[r - 1] == nums2[c - 1]:
                    dp[r][c] = dp[r - 1][c - 1] + 1
                    res = max(res, dp[r][c])
        return res
```

### 3290. Maximum Multiplication Score

```python
class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        @cache
        def f(i, j):
            if i == n:
                return 0 if j == 4 else -inf 
            res = f(i + 1, j)
            if j < 4:
                res = max(res, f(i + 1, j + 1) + a[j] * b[i])
            return res 
        n = len(b)
        return f(0, 0)
```

### 3316. Find Maximum Removals From Source String

```python
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        @cache
        def f(i, j):
            if i < 0:
                if j >= 0:
                    return -inf
                return 0 
            res = f(i - 1, j) + (i in targetIndices) # delete
            if j >= 0 and source[i] == pattern[j]:
                res = max(res, f(i - 1, j - 1)) # not delete
            return res 
        res = f(len(source) - 1, len(pattern) - 1)
        f.cache_clear()
        return res 
```