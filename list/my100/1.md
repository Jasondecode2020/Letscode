# My 100

## Question List(1-10)

* [5. Longest Palindromic Substring](#5-longest-palindromic-substring)
* [647. Palindromic Substrings](#647-palindromic-substrings)
* [516. Longest Palindromic Subsequence](#516-longest-palindromic-subsequence)
* [1682. Longest Palindromic Subsequence II](#1682-longest-palindromic-subsequence-ii)
* [70. Climbing Stairs](#70-climbing-stairs)
* [509. Fibonacci Number](#509-fibonacci-number) 
* [1137. N-th Tribonacci Number](#1137-n-th-tribonacci-number) 
* [746. Min Cost Climbing Stairs](#746-min-cost-climbing-stairs) 
* [377. Combination Sum IV](#377-combination-sum-iv) 
* [2466. Count Ways To Build Good Strings](#2466-count-ways-to-build-good-strings) 

## Question List(11-20)

* [2533. Number of Good Binary Strings](#2533-number-of-good-binary-strings) 
* [2266. Count Number of Texts](#2266-count-number-of-texts)
* [2400. Number of Ways to Reach a Position After Exactly k Steps](#2400-number-of-ways-to-reach-a-position-after-exactly-k-steps)
* [198. House Robber](#198-house-robber) 
* [740. Delete and Earn](#740-delete-and-earn) 
* [213. House Robber II](#213-house-robber-ii) 
* [2320. Count Number of Ways to Place Houses](#2320-count-number-of-ways-to-place-houses) 
* [256. Paint House](#256-paint-house) 
* [265. Paint House II](#265-paint-house-ii) 
* [276. Paint Fence](#276-paint-fence) 
* [3186. Maximum Total Damage With Spell Casting](#3186-maximum-total-damage-with-spell-casting)

### 5. Longest Palindromic Substring

- center spreading

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def helper(i, j):
            while i >= 0 and j < n and s[i] == s[j]:
                i -= 1
                j += 1
            return s[i + 1: j]
        
        n, res = len(s), ''
        for i in range(n):
            res = max(res, helper(i, i), helper(i, i + 1), key = len)
        return res 
```

- dp

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n, res = len(s), ''
        f = [[False] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i <= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                    res = max(res, s[i: j + 1], key = len)
        return res 
```

### 647. Palindromic Substrings

- center spreading

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        def helper(i, j):
            res = 0
            while i >= 0 and j < n and s[i] == s[j]:
                i -= 1
                j += 1
                res += 1
            return res
        
        n, res = len(s), 0
        for i in range(n):
            res += helper(i, i) + helper(i, i + 1)
        return res 
```

- dp

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        n, res = len(s), 0
        f = [[False] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i <= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                    res += 1
        return res 
```

### 516. Longest Palindromic Subsequence

- dfs + cache

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        @cache
        def dfs(i, j):
            if j < i:
                return 0
            if i == j:
                return 1
            res = 0
            if s[i] == s[j]:
                res = max(res, dfs(i + 1, j - 1) + 2)
            else:
                res = max(res, dfs(i + 1, j), dfs(i, j - 1))
            return res 
        return dfs(0, len(s) - 1)
```

- dp

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            f[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1] + 2
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return f[0][n - 1]
```

### 1682. Longest Palindromic Subsequence II

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        @cache 
        def dfs(i, j, prev):
            if i >= j:
                return 0
            res = 0
            if s[i] == s[j] and s[i] != prev:
                res += dfs(i + 1, j - 1, s[i]) + 2
            else:
                res += max(dfs(i + 1, j, prev), dfs(i, j - 1, prev))
            return res 
        return dfs(0, len(s) - 1, None)
```

### 70. Climbing Stairs

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        first, second = 1, 2
        for n in range(3, n + 1):
            second, first = second + first, second 
        return second if n >= 2 else 1
```

### 509. Fibonacci Number

```python
class Solution:
    def fib(self, n: int) -> int:
        first, second = 0, 1
        for i in range(2, n + 1):
            second, first = first + second, second
        return second if n >= 1 else 0
```

### 1137. N-th Tribonacci Number

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        first, second, third = 0, 1, 1
        for i in range(3, n + 1):
            third, second, first = third + second + first, third, second
        return third if n >= 1 else first
```

### 746. Min Cost Climbing Stairs

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        for i in range(2, n):
            cost[i] += min(cost[i - 2], cost[i - 1])
        return min(cost[-2:])
```

### 377. Combination Sum IV 

- (unbounded knapsack)

- climbing stairs idea

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache
        def f(x):
            if x == target:
                return 1
            if x > target:
                return 0
            res = 0
            for n in nums:
                res += f(x + n)
            return res 
        return f(0)
```

### 2466. Count Ways To Build Good Strings

- same as 2533 (unbounded knapsack), use t from low to high is better

```python
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def f(t):
            if t == 0:
                return 1
            if t < 0:
                return 0
            res = 0
            for n in [zero, one]:
                res = (res + f(t - n)) % mod
            return res 
        return sum(f(i) for i in range(low, high + 1)) % mod
```

### 2533. Number of Good Binary Strings

- same as 2466 (unbounded knapsack)

```python
class Solution:
    def goodBinaryStrings(self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def f(t):
            if t == 0:
                return 1
            if t < 0:
                return 0
            res = 0
            for x in [oneGroup, zeroGroup]:
                res = (res + f(t - x)) % mod
            return res
        return sum(f(i) for i in range(minLength, maxLength + 1)) % mod 
```

### 2266. Count Number of Texts

```python
class Solution:
    def countTexts(self, pressedKeys: str) -> int:
        mod = 10 ** 9 + 7
        def f(c, count):
            first, second, third, fourth = 1, 1, 2, 4
            for _ in range(4, count + 1):
                if c in '234568':
                    fourth, third, second, first = fourth + third + second, fourth, third, second 
                else:
                    fourth, third, second, first = fourth + third + second + first, fourth, third, second 
            return fourth % mod 
        res = 1
        for c, s in groupby(pressedKeys):
            count = len(list(s))
            if count <= 2:
                res = (res * count) % mod 
            else:
                res = (res * f(c, count)) % mod 
        return res 
```

### 2400. Number of Ways to Reach a Position After Exactly k Steps

```python
class Solution:
    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def dfs(pos, step):
            if step == k:
                return pos == endPos
            if abs(pos - endPos) > k:
                return 0
            return (dfs(pos + 1, step + 1) + dfs(pos - 1, step + 1)) % mod
        return dfs(startPos, 0)
```

### 198. House Robber

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        nums = [0] + nums
        n = len(nums)
        for i in range(2, n):
            nums[i] = max(nums[i - 1], nums[i] + nums[i - 2])
        return nums[-1]
```

### 740. Delete and Earn

```python
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        f = [0] * (max(nums) + 1)
        for n in nums:
            f[n] += n
        
        n = len(f)
        for i in range(2, n):
            f[i] = max(f[i - 1], f[i] + f[i - 2])
        return f[-1]
```

### 213. House Robber II

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        def rob1(nums):
            nums = [0] + nums 
            n = len(nums)
            for i in range(2, n):
                nums[i] = max(nums[i - 1], nums[i] + nums[i - 2])
            return nums[-1]
        return max(rob1(nums[1:]), rob1(nums[:-1])) if len(nums) > 1 else nums[0]
```

### 2320. Count Number of Ways to Place Houses

```python
class Solution:
    def countHousePlacements(self, n: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def f(i, rob):
            if i == n:
                return 1
            res = 0
            if rob:
                res += f(i + 1, not rob)
            else:
                res += f(i + 1, rob) + f(i + 1, not rob)
            return res 
        res = f(0, False) % mod 
        return (res * res) % mod
```

### 256. Paint House

```python
class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        n = len(costs)
        for i in range(1, n):
            for j in range(3):
                costs[i][j] += min(costs[i - 1][:j] + costs[i - 1][j + 1:])
        return min(costs[-1])
```

### 265. Paint House II

```python
class Solution:
    def minCostII(self, costs: List[List[int]]) -> int:
        n = len(costs)
        for i in range(1, n):
            for j in range(len(costs[0])):
                costs[i][j] += min(costs[i - 1][:j] + costs[i - 1][j + 1:])
        return min(costs[-1])
```

### 276. Paint Fence

```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        @cache
        def dfs(i):
            if i == 1:
                return k 
            if i == 2:
                return k * k
            return (dfs(i - 1) + dfs(i - 2)) * (k - 1)
        return dfs(n)
```

### 3186. Maximum Total Damage With Spell Casting

```python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        cnt = Counter(power)
        a = sorted(cnt.keys())
        @cache
        def dfs(i):
            if i < 0:
                return 0 
            x = a[i]
            j = i - 1 # a number before current
            while j >= 0 and x - a[j] <= 2: # meet the condition
                j -= 1 # final j didn't meet the condition and use dfs(j)
            return max(dfs(i - 1), dfs(j) + x * cnt[x])
        return dfs(len(a) - 1)
```