## array & string (7)

* [624. Maximum Distance in Arrays](#624-maximum-distance-in-arrays)
* [280. Wiggle Sort](#280-wiggle-sort)
* [1056. Confusing Number](#1056-confusing-number)
* [1427. Perform String Shifts](#1427-perform-string-shifts)
* [161. One Edit Distance](#161-one-edit-distance)
* [186. Reverse Words in a String II](#186-reverse-words-in-a-string-ii)
* [1055. Shortest Way to Form String](#1055-shortest-way-to-form-string)

## sliding window (4)

* [159. Longest Substring with At Most Two Distinct Characters](#159-longest-substring-with-at-most-two-distinct-characters)
* [340. Longest Substring with At Most K Distinct Characters](#340-longest-substring-with-at-most-k-distinct-characters)
* [487. Max Consecutive Ones II](#487-max-consecutive-ones-ii)
* [1100. Find K-Length Substrings With No Repeated Characters](#1100-find-k-length-substrings-with-no-repeated-characters)

## hash (8)

* [266. Palindrome Permutation](#266-palindrome-permutation)
* [760. Find Anagram Mappings](#760-find-anagram-mappings)
* [734. Sentence Similarity](#734-sentence-similarity)
* [1165. Single-Row Keyboard](#1165-single-row-keyboard)
* [249. Group Shifted Strings](#249-group-shifted-strings)
* [1133. Largest Unique Number](#1133-largest-unique-number)
* [1426. Counting Elements](#1426-counting-elements)
* [1198. Find Smallest Common Element in All Rows](#1198-find-smallest-common-element-in-all-rows)

## matrix (2)

* [422. Valid Word Square]()
### 624. Maximum Distance in Arrays

```python
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        res, mn, mx = 0, inf, -inf
        for a in arrays:
            res = max(res, mx - a[0], a[-1] - mn)
            mn = min(mn, a[0])
            mx = max(mx, a[-1])
        return res 
```

### 280. Wiggle Sort

Given an integer array nums, reorder it such that nums[0] <= nums[1] >= nums[2] <= nums[3]....

You may assume the input array always has a valid answer.

Example 1:

Input: nums = [3,5,2,1,6,4]
Output: [3,5,1,6,2,4]
Explanation: [1,6,2,5,3,4] is also accepted.
Example 2:

Input: nums = [6,6,5,6,3,8]
Output: [6,6,5,6,3,8]
 

Constraints:

1 <= nums.length <= 5 * 104
0 <= nums[i] <= 104
It is guaranteed that there will be an answer for the given input nums.

Follow up: Could you solve the problem in O(n) time complexity?

- T: O(n)
- S: O(1)

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        for i in range(2, len(nums), 2):
            nums[i], nums[i - 1] = nums[i - 1], nums[i]
```

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # [3,5,2,1,6,4]
        # [3,5,1,6,2,4]
        for i in range(1, len(nums)):
            if (i % 2 == 1 and nums[i] < nums[i - 1]) or (i % 2 == 0 and nums[i] > nums[i - 1]):
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
```

### 1056. Confusing Number

A confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid.

We can rotate digits of a number by 180 degrees to form new digits.

When 0, 1, 6, 8, and 9 are rotated 180 degrees, they become 0, 1, 9, 8, and 6 respectively.
When 2, 3, 4, 5, and 7 are rotated 180 degrees, they become invalid.
Note that after rotating a number, we can ignore leading zeros.

For example, after rotating 8000, we have 0008 which is considered as just 8.
Given an integer n, return true if it is a confusing number, or false otherwise.

Example 1:

Input: n = 6
Output: true
Explanation: We get 9 after rotating 6, 9 is a valid number, and 9 != 6.

Example 2:

Input: n = 89
Output: true
Explanation: We get 68 after rotating 89, 68 is a valid number and 68 != 89.

Example 3:

Input: n = 11
Output: false
Explanation: We get 11 after rotating 11, 11 is a valid number but the value remains the same, thus 11 is not a confusing number

Constraints:

0 <= n <= 109

```python
class Solution:
    def confusingNumber(self, n: int) -> bool:
        s = str(n)
        d = {a: b for a, b in zip('01689', '01986')}
        res = ''
        for c in s:
            if c not in d:
                return False 
            res = d[c] + res
        return int(res) != n
```

### 1427. Perform String Shifts

You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [directioni, amounti]:

directioni can be 0 (for left shift) or 1 (for right shift).
amounti is the amount by which string s is to be shifted.
A left shift by 1 means remove the first character of s and append it to the end.
Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.
Return the final string after all operations.

Example 1:

Input: s = "abc", shift = [[0,1],[1,2]]
Output: "cab"
Explanation: 
[0,1] means shift to left by 1. "abc" -> "bca"
[1,2] means shift to right by 2. "bca" -> "cab"

Example 2:

Input: s = "abcdefg", shift = [[1,1],[1,1],[0,2],[1,3]]
Output: "efgabcd"
Explanation:  
[1,1] means shift to right by 1. "abcdefg" -> "gabcdef"
[1,1] means shift to right by 1. "gabcdef" -> "fgabcde"
[0,2] means shift to left by 2. "fgabcde" -> "abcdefg"
[1,3] means shift to right by 3. "abcdefg" -> "efgabcd"
 
Constraints:

1 <= s.length <= 100
s only contains lower case English letters.
1 <= shift.length <= 100
shift[i].length == 2
directioni is either 0 or 1.
0 <= amounti <= 100

```python
class Solution:
    def stringShift(self, s: str, shift: List[List[int]]) -> str:
        total_shift = 0
        for d, a in shift:
            if d == 0:
                total_shift -= a 
            else:
                total_shift += a 

        n = len(s)
        total_shift %= n
        if total_shift < 0:
            total_shift += n 
        return s[-total_shift:] + s[: -total_shift]
```

### 161. One Edit Distance

Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.

A string s is said to be one distance apart from a string t if you can:

Insert exactly one character into s to get t.
Delete exactly one character from s to get t.
Replace exactly one character of s with a different character to get t.

Example 1:

Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.

Example 2:

Input: s = "", t = ""
Output: false
Explanation: We cannot get t from s by only one step.

Constraints:

0 <= s.length, t.length <= 104
s and t consist of lowercase letters, uppercase letters, and digits.

```python
class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        ns, nt = len(s), len(t)
        if ns > nt:
            return self.isOneEditDistance(t, s)
        if nt - ns > 1:
            return False

        for i in range(ns):
            if s[i] != t[i]:
                if ns == nt:
                    return s[i + 1:] == t[i + 1:]
                else:
                    return s[i:] == t[i + 1:]
        return ns + 1 == nt
```

### 186. Reverse Words in a String II

Given a character array s, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.

Your code must solve the problem in-place, i.e. without allocating extra space.

Example 1:

Input: s = ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]
Example 2:

Input: s = ["a"]
Output: ["a"]
 
Constraints:

1 <= s.length <= 105
s[i] is an English letter (uppercase or lowercase), digit, or space ' '.
There is at least one word in s.
s does not contain leading or trailing spaces.
All the words in s are guaranteed to be separated by a single space.

```python
class Solution:
    def reverseWords(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        def subReverse(l, r):
            while l < r:
                s[l], s[r] = s[r], s[l]
                l += 1
                r -= 1
    
        n = len(s)
        s.reverse()
        pre = 0
        for i in range(n):
            if s[i] == ' ':
                subReverse(pre, i - 1)
                pre = i + 1
        subReverse(pre, n - 1)
```

### 1055. Shortest Way to Form String

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.

Example 1:

Input: source = "abc", target = "abcbc"
Output: 2
Explanation: The target "abcbc" can be formed by "abc" and "bc", which are subsequences of source "abc".
Example 2:

Input: source = "abc", target = "acdbc"
Output: -1
Explanation: The target string cannot be constructed from the subsequences of source string due to the character "d" in target string.
Example 3:

Input: source = "xyz", target = "xzyxz"
Output: 3
Explanation: The target string can be constructed as follows "xz" + "y" + "xz".
 
Constraints:

1 <= source.length, target.length <= 1000
source and target consist of lowercase English letters.

```python
class Solution:
    def shortestWay(self, source: str, target: str) -> int:
        if set(target) - set(source):
            return -1

        res = 0
        n = len(target)
        j = 0
        while j < n:
            for i, c in enumerate(source):
                if j < n and target[j] == c:
                    j += 1
            res += 1
        return res
```

## sliding window (4)

### 159. Longest Substring with At Most Two Distinct Characters

```python
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        d = Counter()
        l, res = 0, 0
        for r, c in enumerate(s):
            d[c] += 1
            while len(d) > 2:
                d[s[l]] -= 1
                if d[s[l]] == 0:
                    d.pop(s[l])
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 340. Longest Substring with At Most K Distinct Characters

```python
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        d = Counter()
        l, res = 0, 0
        for r, c in enumerate(s):
            d[c] += 1
            while len(d) > k:
                d[s[l]] -= 1
                if d[s[l]] == 0:
                    d.pop(s[l])
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 487. Max Consecutive Ones II

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        count, res, l = 0, 0, 0
        for r, n in enumerate(nums):
            if n == 0:
                count += 1
            while count > 1:
                if nums[l] == 0:
                    count -= 1
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 1100. Find K-Length Substrings With No Repeated Characters

```python
class Solution:
    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        if k > 26:
            return 0
        d, res, l = Counter(), 0, 0
        for r, c in enumerate(s):
            d[c] += 1
            while d[c] > 1:
                d[s[l]] -= 1
                l += 1
            if r - l + 1 >= k:
                res += 1
        return res  
```
### 760. Find Anagram Mappings

```python
class Solution:
    def anagramMappings(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = []
        for n in nums1:
            i = nums2.index(n)
            res.append(i)
            nums2[i] = inf 
        return res
```

### 266. Palindrome Permutation

```python
class Solution:
    def canPermutePalindrome(self, s: str) -> bool:
        d = Counter(s)
        odd = 0
        for k, v in d.items():
            if v % 2 == 1:
                odd += 1
        return odd <= 1
```

### 734. Sentence Similarity

```python
class Solution:
    def areSentencesSimilar(self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]) -> bool:
        s = set((a, b) for a, b in similarPairs)
        if len(sentence1) != len(sentence2):
            return False 
        for a, b in zip(sentence1, sentence2):
            if a != b and ((a, b) not in s and (b, a) not in s):
                return False 
        return True
```

### 1165. Single-Row Keyboard

```python
class Solution:
    def calculateTime(self, keyboard: str, word: str) -> int:
        res = 0
        pre = 0
        for c in word:
            i = keyboard.index(c)
            res += abs(i - pre)
            pre = i 
        return res 
```

### 249. Group Shifted Strings

```python
class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        def check(s):
            res = ''
            dist = ord(s[0]) - ord('a')
            for c in s:
                ans = ord(c) - dist
                if ans >= ord('a'):
                    res += str(ans)
                else:
                    res += str(ans + 26)
            return res

        d = defaultdict(list)
        for s in strings:
            d[check(s)].append(s)
        return list(d.values())
```

### 1133. Largest Unique Number

```python
class Solution:
    def largestUniqueNumber(self, nums: List[int]) -> int:
        d = Counter(nums)
        res = -1
        for k, v in d.items():
            if v == 1:
                res = max(res, k)
        return res 
```

### 1426. Counting Elements

```python
class Solution:
    def countElements(self, arr: List[int]) -> int:
        s = set(arr)
        res = 0
        for n in arr:
            if n + 1 in s:
                res += 1
        return res 
```

### 1198. Find Smallest Common Element in All Rows

```python
class Solution:
    def smallestCommonElement(self, mat: List[List[int]]) -> int:
        d = defaultdict(list)
        for i, a in enumerate(mat):
            for n in a:
                d[n].append(i)
        for n in mat[0]:
            if len(d[n]) == len(mat):
                return n 
        return -1
```

### 422. Valid Word Square

```python
class Solution:
    def validWordSquare(self, words: List[str]) -> bool:
        R, C = len(words), max(len(word) for word in words)
        mat = [[''] * C for r in range(R)]
        for r, row in enumerate(words):
            for c, char in enumerate(row):
                mat[r][c] = char
        cols = []
        for word in zip(*mat):
            cols.append(''.join(word))
        return words == cols
```

### 531. Lonely Pixel I

```python
class Solution:
    def findLonelyPixel(self, picture: List[List[str]]) -> int:
        rowSet, colSet = defaultdict(set), defaultdict(set)
        R, C = len(picture), len(picture[0])
        for r in range(R):
            for c in range(C):
                if picture[r][c] == 'B':
                    rowSet[r].add((r, c))
                    colSet[c].add((r, c))

        res = 0
        for r in range(R):
            for c in range(C):
                if picture[r][c] == 'B' and len(rowSet[r]) == len(colSet[c]) == 1:
                    res += 1
        return res
```

### 311. Sparse Matrix Multiplication

```python
class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
        m, K, n = len(mat1), len(mat1[0]), len(mat2[0])
        mat = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                mat[i][j] = sum(mat1[i][k] * mat2[k][j] for k in range(K))
        return mat
```

### 723. Candy Crush

```python
class Solution:
    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
        R, C = len(board), len(board[0])
        todo = False

        for r in range(R):
            for c in range(C - 2):
                if abs(board[r][c]) == abs(board[r][c+1]) == abs(board[r][c+2]) != 0:
                    board[r][c] = board[r][c+1] = board[r][c+2] = -abs(board[r][c])
                    todo = True

        for r in range(R - 2):
            for c in range(C):
                if abs(board[r][c]) == abs(board[r+1][c]) == abs(board[r+2][c]) != 0:
                    board[r][c] = board[r+1][c] = board[r+2][c] = -abs(board[r][c])
                    todo = True

        for c in range(C):
            write_r = R - 1
            for r in range(R - 1, -1, -1):
                if board[r][c] > 0:
                    board[write_r][c] = board[r][c]
                    write_r -= 1
            for r in range(write_r + 1):
                board[r][c] = 0

        return self.candyCrush(board) if todo else board
```

### 1272. Remove Interval

```python
class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        start, end = toBeRemoved
        res = []
        for s, e in intervals:
            if s >= end or e <= start:
                res.append([s, e])
            else:
                if s < start:
                    res.append([s, start])
                if e > end:
                    res.append([end, e])
        return res
```