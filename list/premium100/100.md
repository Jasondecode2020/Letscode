## 1 Array & string (7)

* [624. Maximum Distance in Arrays](#624-maximum-distance-in-arrays)
* [280. Wiggle Sort](#280-wiggle-sort)
* [1056. Confusing Number](#1056-confusing-number)
* [1427. Perform String Shifts](#1427-perform-string-shifts)
* [161. One Edit Distance](#161-one-edit-distance)
* [186. Reverse Words in a String II](#186-reverse-words-in-a-string-ii)
* [1055. Shortest Way to Form String](#1055-shortest-way-to-form-string)

## 2 Sliding window (4)

* [159. Longest Substring with At Most Two Distinct Characters](#159-longest-substring-with-at-most-two-distinct-characters)
* [340. Longest Substring with At Most K Distinct Characters](#340-longest-substring-with-at-most-k-distinct-characters)
* [487. Max Consecutive Ones II](#487-max-consecutive-ones-ii)
* [1100. Find K-Length Substrings With No Repeated Characters](#1100-find-k-length-substrings-with-no-repeated-characters)

## 3 Hash (8)

* [266. Palindrome Permutation](#266-palindrome-permutation)
* [760. Find Anagram Mappings](#760-find-anagram-mappings)
* [734. Sentence Similarity](#734-sentence-similarity)
* [1165. Single-Row Keyboard](#1165-single-row-keyboard)
* [249. Group Shifted Strings](#249-group-shifted-strings)
* [1133. Largest Unique Number](#1133-largest-unique-number)
* [1426. Counting Elements](#1426-counting-elements)
* [1198. Find Smallest Common Element in All Rows](#1198-find-smallest-common-element-in-all-rows)

## Matrix (2)

* [422. Valid Word Square](#422-valid-word-square)
* [531. Lonely Pixel I](#531-lonely-pixel-i)
* [311. Sparse Matrix Multiplication](#311-sparse-matrix-multiplication)
* [723. Candy Crush](#723-candy-crush)

## Intervals (5)

* [163. Missing Ranges](#163-missing-ranges)
* [252. Meeting Rooms](#252-meeting-rooms)
* [253. Meeting Rooms II]()
* [616. Add Bold Tag in String](#616-add-bold-tag-in-string)
* [1272. Remove Interval](#1272-remove-interval)

## stack (3)

* [439. Ternary Expression Parser](#439-ternary-expression-parser)
* [484. Find Permutation](#484-find-permutation)
* [772. Basic Calculator III](#772-basic-calculator-iii)

## queue (2)

* [346. Moving Average from Data Stream](#346-moving-average-from-data-stream)
* [1429. First Unique Number](#1429-first-unique-number)

## Linked list (4)

* [1474. Delete N Nodes After M Nodes of a Linked List](#1474-delete-n-nodes-after-m-nodes-of-a-linked-list)
* [708. Insert into a Sorted Circular Linked List](#708-insert-into-a-sorted-circular-linked-list)
* [369. Plus One Linked List](#369-plus-one-linked-list)
* [1265. Print Immutable Linked List in Reverse](#1265-print-immutable-linked-list-in-reverse)

## Binary Tree (7)

* [298. Binary Tree Longest Consecutive Sequence](#298-binary-tree-longest-consecutive-sequence)
* [549. Binary Tree Longest Consecutive Sequence II](#549-binary-tree-longest-consecutive-sequence-ii)
* [250. Count Univalue Subtrees](#250-count-univalue-subtrees)
* [1120. Maximum Average Subtree](#1120-maximum-average-subtree)
* [545. Boundary of Binary Tree](#545-boundary-of-binary-tree)
* [366. Find Leaves of Binary Tree](#366-find-leaves-of-binary-tree)
* [314. Binary Tree Vertical Order Traversal](#314-binary-tree-vertical-order-traversal)

## Binary Search Tree (5)

* [270. Closest Binary Search Tree Value](#270-closest-binary-search-tree-value)
* [272. Closest Binary Search Tree Value II](#272-closest-binary-search-tree-value-ii)
* [255. Verify Preorder Sequence in Binary Search Tree](#255-verify-preorder-sequence-in-binary-search-tree)
* [333. Largest BST Subtree](#333-largest-bst-subtree)
* [1214. Two Sum BSTs](#1214-two-sum-bsts)

## N-nary Tree (3)

* [1490. Clone N-ary Tree](#1490-clone-n-ary-tree)
* [1506. Find Root of N-Ary Tree](#1506-find-root-of-n-ary-tree)
* [1522. Diameter of N-Ary Tree](#1522-diameter-of-n-ary-tree)

## graph (8)

* [277. Find the Celebrity]()

### 624. Maximum Distance in Arrays

```python
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        res, mn, mx = 0, inf, -inf
        for a in arrays:
            res = max(res, mx - a[0], a[-1] - mn)
            mn = min(mn, a[0])
            mx = max(mx, a[-1])
        return res 
```

### 280. Wiggle Sort

Given an integer array nums, reorder it such that nums[0] <= nums[1] >= nums[2] <= nums[3]....

You may assume the input array always has a valid answer.

Example 1:

Input: nums = [3,5,2,1,6,4]
Output: [3,5,1,6,2,4]
Explanation: [1,6,2,5,3,4] is also accepted.
Example 2:

Input: nums = [6,6,5,6,3,8]
Output: [6,6,5,6,3,8]
 

Constraints:

1 <= nums.length <= 5 * 104
0 <= nums[i] <= 104
It is guaranteed that there will be an answer for the given input nums.

Follow up: Could you solve the problem in O(n) time complexity?

- T: O(n)
- S: O(1)

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        for i in range(2, len(nums), 2):
            nums[i], nums[i - 1] = nums[i - 1], nums[i]
```

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # [3,5,2,1,6,4]
        # [3,5,1,6,2,4]
        for i in range(1, len(nums)):
            if (i % 2 == 1 and nums[i] < nums[i - 1]) or (i % 2 == 0 and nums[i] > nums[i - 1]):
                nums[i], nums[i - 1] = nums[i - 1], nums[i]
```

### 1056. Confusing Number

A confusing number is a number that when rotated 180 degrees becomes a different number with each digit valid.

We can rotate digits of a number by 180 degrees to form new digits.

When 0, 1, 6, 8, and 9 are rotated 180 degrees, they become 0, 1, 9, 8, and 6 respectively.
When 2, 3, 4, 5, and 7 are rotated 180 degrees, they become invalid.
Note that after rotating a number, we can ignore leading zeros.

For example, after rotating 8000, we have 0008 which is considered as just 8.
Given an integer n, return true if it is a confusing number, or false otherwise.

Example 1:

Input: n = 6
Output: true
Explanation: We get 9 after rotating 6, 9 is a valid number, and 9 != 6.

Example 2:

Input: n = 89
Output: true
Explanation: We get 68 after rotating 89, 68 is a valid number and 68 != 89.

Example 3:

Input: n = 11
Output: false
Explanation: We get 11 after rotating 11, 11 is a valid number but the value remains the same, thus 11 is not a confusing number

Constraints:

0 <= n <= 109

```python
class Solution:
    def confusingNumber(self, n: int) -> bool:
        s = str(n)
        d = {a: b for a, b in zip('01689', '01986')}
        res = ''
        for c in s:
            if c not in d:
                return False 
            res = d[c] + res
        return int(res) != n
```

### 1427. Perform String Shifts

You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [directioni, amounti]:

directioni can be 0 (for left shift) or 1 (for right shift).
amounti is the amount by which string s is to be shifted.
A left shift by 1 means remove the first character of s and append it to the end.
Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.
Return the final string after all operations.

Example 1:

Input: s = "abc", shift = [[0,1],[1,2]]
Output: "cab"
Explanation: 
[0,1] means shift to left by 1. "abc" -> "bca"
[1,2] means shift to right by 2. "bca" -> "cab"

Example 2:

Input: s = "abcdefg", shift = [[1,1],[1,1],[0,2],[1,3]]
Output: "efgabcd"
Explanation:  
[1,1] means shift to right by 1. "abcdefg" -> "gabcdef"
[1,1] means shift to right by 1. "gabcdef" -> "fgabcde"
[0,2] means shift to left by 2. "fgabcde" -> "abcdefg"
[1,3] means shift to right by 3. "abcdefg" -> "efgabcd"
 
Constraints:

1 <= s.length <= 100
s only contains lower case English letters.
1 <= shift.length <= 100
shift[i].length == 2
directioni is either 0 or 1.
0 <= amounti <= 100

```python
class Solution:
    def stringShift(self, s: str, shift: List[List[int]]) -> str:
        total_shift = 0
        for d, a in shift:
            if d == 0:
                total_shift -= a 
            else:
                total_shift += a 

        n = len(s)
        total_shift %= n
        if total_shift < 0:
            total_shift += n 
        return s[-total_shift:] + s[: -total_shift]
```

### 161. One Edit Distance

Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.

A string s is said to be one distance apart from a string t if you can:

Insert exactly one character into s to get t.
Delete exactly one character from s to get t.
Replace exactly one character of s with a different character to get t.

Example 1:

Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.

Example 2:

Input: s = "", t = ""
Output: false
Explanation: We cannot get t from s by only one step.

Constraints:

0 <= s.length, t.length <= 104
s and t consist of lowercase letters, uppercase letters, and digits.

```python
class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        ns, nt = len(s), len(t)
        if ns > nt:
            return self.isOneEditDistance(t, s)
        if nt - ns > 1:
            return False

        for i in range(ns):
            if s[i] != t[i]:
                if ns == nt:
                    return s[i + 1:] == t[i + 1:]
                else:
                    return s[i:] == t[i + 1:]
        return ns + 1 == nt
```

### 186. Reverse Words in a String II

Given a character array s, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in s will be separated by a single space.

Your code must solve the problem in-place, i.e. without allocating extra space.

Example 1:

Input: s = ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]
Example 2:

Input: s = ["a"]
Output: ["a"]
 
Constraints:

1 <= s.length <= 105
s[i] is an English letter (uppercase or lowercase), digit, or space ' '.
There is at least one word in s.
s does not contain leading or trailing spaces.
All the words in s are guaranteed to be separated by a single space.

```python
class Solution:
    def reverseWords(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        def subReverse(l, r):
            while l < r:
                s[l], s[r] = s[r], s[l]
                l += 1
                r -= 1
    
        n = len(s)
        s.reverse()
        pre = 0
        for i in range(n):
            if s[i] == ' ':
                subReverse(pre, i - 1)
                pre = i + 1
        subReverse(pre, n - 1)
```

### 1055. Shortest Way to Form String

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.

Example 1:

Input: source = "abc", target = "abcbc"
Output: 2
Explanation: The target "abcbc" can be formed by "abc" and "bc", which are subsequences of source "abc".
Example 2:

Input: source = "abc", target = "acdbc"
Output: -1
Explanation: The target string cannot be constructed from the subsequences of source string due to the character "d" in target string.
Example 3:

Input: source = "xyz", target = "xzyxz"
Output: 3
Explanation: The target string can be constructed as follows "xz" + "y" + "xz".
 
Constraints:

1 <= source.length, target.length <= 1000
source and target consist of lowercase English letters.

```python
class Solution:
    def shortestWay(self, source: str, target: str) -> int:
        if set(target) - set(source):
            return -1

        res = 0
        n = len(target)
        j = 0
        while j < n:
            for i, c in enumerate(source):
                if j < n and target[j] == c:
                    j += 1
            res += 1
        return res
```

## sliding window (4)

### 159. Longest Substring with At Most Two Distinct Characters

```python
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        d = Counter()
        l, res = 0, 0
        for r, c in enumerate(s):
            d[c] += 1
            while len(d) > 2:
                d[s[l]] -= 1
                if d[s[l]] == 0:
                    d.pop(s[l])
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 340. Longest Substring with At Most K Distinct Characters

```python
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        d = Counter()
        l, res = 0, 0
        for r, c in enumerate(s):
            d[c] += 1
            while len(d) > k:
                d[s[l]] -= 1
                if d[s[l]] == 0:
                    d.pop(s[l])
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 487. Max Consecutive Ones II

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        count, res, l = 0, 0, 0
        for r, n in enumerate(nums):
            if n == 0:
                count += 1
            while count > 1:
                if nums[l] == 0:
                    count -= 1
                l += 1
            res = max(res, r - l + 1)
        return res 
```

### 1100. Find K-Length Substrings With No Repeated Characters

```python
class Solution:
    def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:
        if k > 26:
            return 0
        d, res, l = Counter(), 0, 0
        for r, c in enumerate(s):
            d[c] += 1
            while d[c] > 1:
                d[s[l]] -= 1
                l += 1
            if r - l + 1 >= k:
                res += 1
        return res  
```
### 760. Find Anagram Mappings

```python
class Solution:
    def anagramMappings(self, nums1: List[int], nums2: List[int]) -> List[int]:
        res = []
        for n in nums1:
            i = nums2.index(n)
            res.append(i)
            nums2[i] = inf 
        return res
```

### 266. Palindrome Permutation

```python
class Solution:
    def canPermutePalindrome(self, s: str) -> bool:
        d = Counter(s)
        odd = 0
        for k, v in d.items():
            if v % 2 == 1:
                odd += 1
        return odd <= 1
```

### 734. Sentence Similarity

```python
class Solution:
    def areSentencesSimilar(self, sentence1: List[str], sentence2: List[str], similarPairs: List[List[str]]) -> bool:
        s = set((a, b) for a, b in similarPairs)
        if len(sentence1) != len(sentence2):
            return False 
        for a, b in zip(sentence1, sentence2):
            if a != b and ((a, b) not in s and (b, a) not in s):
                return False 
        return True
```

### 1165. Single-Row Keyboard

```python
class Solution:
    def calculateTime(self, keyboard: str, word: str) -> int:
        res = 0
        pre = 0
        for c in word:
            i = keyboard.index(c)
            res += abs(i - pre)
            pre = i 
        return res 
```

### 249. Group Shifted Strings

```python
class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        def check(s):
            res = ''
            dist = ord(s[0]) - ord('a')
            for c in s:
                ans = ord(c) - dist
                if ans >= ord('a'):
                    res += str(ans)
                else:
                    res += str(ans + 26)
            return res

        d = defaultdict(list)
        for s in strings:
            d[check(s)].append(s)
        return list(d.values())
```

### 1133. Largest Unique Number

```python
class Solution:
    def largestUniqueNumber(self, nums: List[int]) -> int:
        d = Counter(nums)
        res = -1
        for k, v in d.items():
            if v == 1:
                res = max(res, k)
        return res 
```

### 1426. Counting Elements

```python
class Solution:
    def countElements(self, arr: List[int]) -> int:
        s = set(arr)
        res = 0
        for n in arr:
            if n + 1 in s:
                res += 1
        return res 
```

### 1198. Find Smallest Common Element in All Rows

```python
class Solution:
    def smallestCommonElement(self, mat: List[List[int]]) -> int:
        d = defaultdict(list)
        for i, a in enumerate(mat):
            for n in a:
                d[n].append(i)
        for n in mat[0]:
            if len(d[n]) == len(mat):
                return n 
        return -1
```

### 422. Valid Word Square

```python
class Solution:
    def validWordSquare(self, words: List[str]) -> bool:
        R, C = len(words), max(len(word) for word in words)
        mat = [[''] * C for r in range(R)]
        for r, row in enumerate(words):
            for c, char in enumerate(row):
                mat[r][c] = char
        cols = []
        for word in zip(*mat):
            cols.append(''.join(word))
        return words == cols
```

### 531. Lonely Pixel I

```python
class Solution:
    def findLonelyPixel(self, picture: List[List[str]]) -> int:
        rowSet, colSet = defaultdict(set), defaultdict(set)
        R, C = len(picture), len(picture[0])
        for r in range(R):
            for c in range(C):
                if picture[r][c] == 'B':
                    rowSet[r].add((r, c))
                    colSet[c].add((r, c))

        res = 0
        for r in range(R):
            for c in range(C):
                if picture[r][c] == 'B' and len(rowSet[r]) == len(colSet[c]) == 1:
                    res += 1
        return res
```

### 311. Sparse Matrix Multiplication

```python
class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
        m, K, n = len(mat1), len(mat1[0]), len(mat2[0])
        mat = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                mat[i][j] = sum(mat1[i][k] * mat2[k][j] for k in range(K))
        return mat
```

### 723. Candy Crush

```python
class Solution:
    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
        R, C = len(board), len(board[0])
        todo = False

        for r in range(R):
            for c in range(C - 2):
                if abs(board[r][c]) == abs(board[r][c+1]) == abs(board[r][c+2]) != 0:
                    board[r][c] = board[r][c+1] = board[r][c+2] = -abs(board[r][c])
                    todo = True

        for r in range(R - 2):
            for c in range(C):
                if abs(board[r][c]) == abs(board[r+1][c]) == abs(board[r+2][c]) != 0:
                    board[r][c] = board[r+1][c] = board[r+2][c] = -abs(board[r][c])
                    todo = True

        for c in range(C):
            write_r = R - 1
            for r in range(R - 1, -1, -1):
                if board[r][c] > 0:
                    board[write_r][c] = board[r][c]
                    write_r -= 1
            for r in range(write_r + 1):
                board[r][c] = 0

        return self.candyCrush(board) if todo else board
```

### 163. Missing Ranges

```python
class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[List[int]]:
        nums = [lower - 1] + nums + [upper + 1]
        res = []
        for a, b in pairwise(nums):
            if b - a > 1:
                res.append([a + 1, b - 1])
        return res 
```

### 252. Meeting Rooms

```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        pq = []
        intervals.sort()
        for s, e in intervals:
            if pq and s >= pq[0]:
                heappop(pq)
                heappush(pq, e)
            else:
                heappush(pq, e)
        return len(pq) <= 1
```

### 253. Meeting Rooms II

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        pq = []
        for s, e in intervals:
            if pq and s >= pq[0]:
                heappop(pq)
                heappush(pq, e)
            else:
                heappush(pq, e)
        return len(pq)
```

### 616. Add Bold Tag in String

- same as 758

```python
class Solution:
    def addBoldTag(self, s: str, words: List[str]) -> str:
        n = len(s)
        res = [0] * n
        for i in range(n):
            for w in words:
                if s[i:].startswith(w):
                    for j in range(i, i + len(w)):
                        res[j] = 1
        
        i, ans = 0, ''
        while i < n:
            start = i 
            j = start 
            while j < n and res[start] == res[j]:
                j += 1
            if res[start] == 0:
                ans += s[start: j]
            else:
                ans += '<b>' + s[start: j] + '</b>'
            i = j 
        return ans
```

### 1272. Remove Interval

```python
class Solution:
    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -> List[List[int]]:
        start, end = toBeRemoved
        res = []
        for s, e in intervals:
            if s >= end or e <= start:
                res.append([s, e])
            else:
                if s < start:
                    res.append([s, start])
                if e > end:
                    res.append([end, e])
        return res 
```

### 439. Ternary Expression Parser

```python
class Solution:
    def parseTernary(self, expression: str) -> str:
        n = len(expression)
        i = n - 1
        stack = []
        while i >= 0:
            if expression[i].isalnum():
                stack.append(expression[i])
            elif expression[i] == '?':
                i -= 1
                left = stack.pop()
                right = stack.pop()
                if expression[i] == 'T':
                    stack.append(left)
                else:
                    stack.append(right)
            i -= 1
        return stack.pop()
```

### 484. Find Permutation

```pyhton
class Solution:
    def findPermutation(self, s: str) -> List[int]:
        s += 'I'
        stack, res = [], []
        for i, c in enumerate(s):
            stack.append(i + 1)
            if c == 'I':
                res += stack[::-1]
                stack = []
        return res 
```

### 772. Basic Calculator III

```python
class Solution:
    def calculate(self, s: str) -> int:
        def helper(q):
            stack, pre, num = [], '+', 0
            while q:
                c = q.popleft()
                if c.isdigit():
                    num = num * 10 + int(c)
                if c == '(':
                    num = helper(q)
                if c in '+-*/)' or not q:
                    if pre == '+':
                        stack.append(num)
                    elif pre == '-':
                        stack.append(-num)
                    elif pre == '*':
                        stack.append(stack.pop() * num)
                    elif pre == '/':
                        stack.append(int(stack.pop() / num))
                    num, pre = 0, c
                if c == ')':
                    break 
            return sum(stack)
        return helper(deque(s))
```

### 346. Moving Average from Data Stream

```python
class MovingAverage:

    def __init__(self, size: int):
        self.size = size 
        self.q = deque()
        self.num = 0
        self.s = 0

    def next(self, val: int) -> float:
        self.q.append(val)
        self.num += 1
        self.s += val 
        if self.num > self.size:
            n = self.q.popleft()
            self.s -= n 
        return self.s / len(self.q)
```

### 1429. First Unique Number

```python
class FirstUnique:

    def __init__(self, nums: List[int]):
        self.d = Counter(nums)
        self.q = deque(nums)

    def showFirstUnique(self) -> int:
        while self.q:
            if self.d[self.q[0]] == 1:
                return self.q[0]
            else:
                self.q.popleft()
        return -1

    def add(self, value: int) -> None:
        self.d[value] += 1
        self.q.append(value)
```

### 1474. Delete N Nodes After M Nodes of a Linked List

```python
class Solution:
    def deleteNodes(self, head: Optional[ListNode], m: int, n: int) -> Optional[ListNode]:
        p = dummy = ListNode()
        p.next = head 
        cntM, cntN = 0, 0
        while p.next:
            p = p.next 
            cntM += 1
            if cntM == m:
                cntM = 0
                while p.next:
                    p.next = p.next.next 
                    cntN += 1
                    if cntN == n:
                        cntN = 0
                        break 
        return dummy.next 
```

### 708. Insert into a Sorted Circular Linked List

```python
class Solution:
    def insert(self, head: 'Optional[Node]', insertVal: int) -> 'Node':
        node = Node(insertVal)
        if not head:
            node.next = node 
            return node 
        cur = head.next 
        while cur != head:
            if cur.val <= insertVal <= cur.next.val:
                break
            if cur.val > cur.next.val:
                if cur.val <= insertVal or cur.next.val >= insertVal:
                    break
            cur = cur.next 
        node.next = cur.next 
        cur.next = node 
        return head 
```

### 369. Plus One Linked List

```python
class Solution:
    def plusOne(self, head: ListNode) -> ListNode:
        # 1 -> 2 -> 3
        def reverseList(prev, cur):
            if not cur:
                return prev
            nxt = cur.next
            cur.next = prev
            return reverseList(cur, nxt)
        p = reverseList(None, head)
        # 3 -> 2 -> 1
        carry = 1
        head = p
        while p:
            value = p.val + carry
            p.val = (value) % 10
            carry = value // 10
            if p.next:
                p = p.next
            else:
                break
        # 4 -> 2 -> 1
        if carry:
            p.next = ListNode(1)
        # 1 -> 2 -> 4
        return  reverseList(None, head)
```

### 1265. Print Immutable Linked List in Reverse

```python
class Solution:
    def printLinkedListInReverse(self, head: 'ImmutableListNode') -> None:
        stack = []
        while head:
            stack.append(head)
            head = head.getNext()

        while stack:
            stack.pop().printValue()
```

### 298. Binary Tree Longest Consecutive Sequence

```python
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if not node:
                return 0
            l, r = dfs(node.left), dfs(node.right)
            ans = 1
            if node.left and node.val + 1 == node.left.val:
                ans = max(ans, l + 1)
            if node.right and node.val + 1 == node.right.val:
                ans = max(ans, r + 1)
            self.res = max(self.res, ans)
            return ans 

        self.res = 0
        dfs(root)
        return self.res
```

### 549. Binary Tree Longest Consecutive Sequence II

```python
class Solution:
    def longestConsecutive(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if not node:
                return 0, 0
            l, r = dfs(node.left), dfs(node.right)
            inc, dec = 1, 1
            if node.left:
                if node.val + 1 == node.left.val:
                    inc = max(inc, l[0] + 1)
                elif node.val - 1 == node.left.val:
                    dec = max(dec, l[1] + 1)
            if node.right:
                if node.val + 1 == node.right.val:
                    inc = max(inc, r[0] + 1)
                elif node.val - 1 == node.right.val:
                    dec = max(dec, r[1] + 1)
            self.res = max(self.res, inc + dec - 1)
            return inc, dec 

        self.res = 0
        dfs(root)
        return self.res 
```

### 250. Count Univalue Subtrees

```python
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:
        def checkUni(node, s):
            if node:
                s.add(node.val)
                if len(s) == 2:
                    return False
                checkUni(node.left, s)
                checkUni(node.right, s)
            return len(s) == 1

        self.res = 0
        def dfs(node):
            if node:
                if checkUni(node, set()):
                    self.res += 1
                dfs(node.left)
                dfs(node.right)
        dfs(root)
        return self.res
```

### 1120. Maximum Average Subtree

```python
class Solution:
    def maximumAverageSubtree(self, root: Optional[TreeNode]) -> float:
        def dfs(node):
            if not node:
                return 0, 0
            leftNum, leftVal = dfs(node.left)
            rightNum, rightVal = dfs(node.right)
            self.res = max(self.res, (leftVal + rightVal + node.val) / (leftNum + rightNum + 1))
            return leftNum + rightNum + 1, leftVal + rightVal + node.val 
        self.res = 0
        dfs(root)
        return self.res
```

### 545. Boundary of Binary Tree

```python
class Solution:
    def boundaryOfBinaryTree(self, root: Optional[TreeNode]) -> List[int]:
        if not root.left and not root.right:
            return [root.val]

        left, right, bottom = [], [], []
        def dfsLeft(node):
            if node and (node.left or node.right):
                left.append(node.val)
                if node.left:
                    dfsLeft(node.left)
                else:
                    dfsLeft(node.right)
        
        def dfsRight(node):
            if node and (node.left or node.right):
                right.append(node.val)
                if node.right:
                    dfsRight(node.right)
                else:
                    dfsRight(node.left)

        def dfsBottom(node):
            if node:
                if not node.left and not node.right:
                    bottom.append(node.val)
                dfsBottom(node.left)
                dfsBottom(node.right)

        dfsLeft(root.left)
        dfsRight(root.right)
        dfsBottom(root)
        return [root.val] + left + bottom + right[::-1]
```

### 366. Find Leaves of Binary Tree

```python
class Solution:
    def findLeaves(self, root: Optional[TreeNode]) -> List[List[int]]:
        def dfs(node):
            if not node:
                return 0
            l, r = dfs(node.left), dfs(node.right)
            depth = max(l, r) + 1
            d[depth].append(node.val)
            return depth

        d = defaultdict(list)
        dfs(root)
        return list(d.values())
```

### 314. Binary Tree Vertical Order Traversal

```python
class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        d = defaultdict(list)
        q = deque([(root, 0)])
        while q:
            node, level = q.popleft()
            d[level].append(node.val)
            if node.left:
                q.append((node.left, level - 1))
            if node.right:
                q.append((node.right, level + 1))
        return [d[i] for i in sorted(d.keys())]
```

### 270. Closest Binary Search Tree Value

```python
class Solution:
    def closestValue(self, root: Optional[TreeNode], target: float) -> int:
        def dfs(node):
            if node:
                dfs(node.left)
                if abs(node.val - target) < abs(self.res - target):
                    self.res = node.val
                dfs(node.right)
        self.res = inf
        dfs(root)
        return self.res
```

### 272. Closest Binary Search Tree Value II

```python
class Solution:
    def closestKValues(self, root: Optional[TreeNode], target: float, k: int) -> List[int]:
        pq = []
        def dfs(node):
            if node:
                heappush(pq, (abs(target - node.val), node.val))
                dfs(node.left)
                dfs(node.right)
        dfs(root)

        res = []
        for i in range(k):
            res.append(heappop(pq)[1])
        return res 
```

### 255. Verify Preorder Sequence in Binary Search Tree

```python
class Solution:
    def verifyPreorder(self, preorder: List[int]) -> bool:
        stack, mn = [], -inf 
        for i, n in enumerate(preorder):
            if n < mn:
                return False
            while stack and preorder[stack[-1]] < n:
                mn = preorder[stack.pop()]
            stack.append(i)
        return True
```

### 333. Largest BST Subtree

```python
class Solution:
    def largestBSTSubtree(self, root: Optional[TreeNode]) -> int:
        def valid(node, l, r):
            if not node:
                return True
            v = node.val 
            self.cnt += 1
            if v <= l or v >= r:
                return False
            return valid(node.left, l, v) and valid(node.right, v, r)

        def dfs(node):
            if node:
                self.cnt = 0
                if valid(node, -inf, inf):
                    self.res = max(self.res, self.cnt)
                dfs(node.left)
                dfs(node.right)
        
        self.res = 0
        dfs(root)
        return self.res
```

### 1214. Two Sum BSTs

```python
class Solution:
    def twoSumBSTs(self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int) -> bool:
        s = set()
        def dfs(node):
            if node:
                s.add(node.val)
                dfs(node.left)
                dfs(node.right)
        dfs(root1)

        def dfs2(node):
            if node:
                res = target - node.val
                if res in s:
                    self.res = True
                    return
                dfs2(node.left) 
                dfs2(node.right)

        dfs(root1)
        self.res = False
        dfs2(root2)
        return self.res
```

### 1490. Clone N-ary Tree

```python
class Solution:
    def cloneTree(self, root: 'Node') -> 'Node':
        def dfs(node):
            if not node:
                return None
            cur = Node(node.val)
            for child in node.children:
                cur.children.append(dfs(child))
            return cur 
        return dfs(root)
```

### 1506. Find Root of N-Ary Tree

```python
class Solution:
    def findRoot(self, tree: List['Node']) -> 'Node':
        res = set()
        for t in tree:
            for child in t.children:
                res.add(child.val)
            
        for t in tree:
            if t.val not in res:
                return t 
```

### 1522. Diameter of N-Ary Tree

```python
class Solution:
    def diameter(self, root: 'Node') -> int:
        """
        :type root: 'Node'
        :rtype: int
        """
        def dfs(node):
            first = 0
            for child in node.children:
                second = dfs(child) + 1
                self.res = max(self.res, first + second)
                first = max(first, second)
            return first
        self.res = 0
        dfs(root)
        return self.res 
```

### 277. Find the Celebrity

```python
class Solution:
    def findCelebrity(self, n: int) -> int:
        def check(i):
            for j in range(n):
                if i != j and knows(i, j) or not knows(j, i):
                    return False
            return True 

        c = 0
        for i in range(1, n):
            if knows(c, i):
                c = i 
        if check(c):
            return c 
        return -1
```

### 582. Kill Process

```python
class Solution:
    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:
        g = defaultdict(list)
        for a, b in zip(pid, ppid):
            g[b].append(a)

        def dfs(x, res):
            res.append(x)
            for y in g[x]:
                dfs(y, res)
            return res
        return dfs(kill, [])
```

### 323. Number of Connected Components in an Undirected Graph

```python
class UF:
    def __init__(self, n):
        self.parent = list(range(n))

    def find(self, n):
        while n != self.parent[n]:
            self.parent[n] = self.parent[self.parent[n]]
            n = self.parent[n]
        return n

    def connected(self, n1, n2):
        return self.find(n1) == self.find(n2)

    def union(self, n1, n2):
        p1, p2 = self.find(n1), self.find(n2)
        self.parent[p2] = p1

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UF(n)
        for u, v in edges:
            if not uf.connected(u, v):
                uf.union(u, v)
                n -= 1
        return n
```

### 1059. All Paths from Source Lead to Destination

```python
class Solution:
    def leadsToDestination(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        g, indegree = defaultdict(list), [0] * n 
        for a, b in edges:
            g[b].append(a)
            indegree[a] += 1

        if indegree[destination]:
            return False

        q = deque([destination])
        while q:
            node = q.popleft()
            if node == source:
                return True
            for nei in g[node]:
                indegree[nei] -= 1
                if indegree[nei] == 0:
                    q.append(nei)
        return False
```

### 1236. Web Crawler

```python 
class Solution:
    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
        url_arr = startUrl.split('/')
        url_arr[1] = '//'
        include_pattern = ''.join(url_arr[:3])
        q = deque([startUrl])
        visited = set([startUrl])
        while q:
            start_url = q.popleft()
            urls = htmlParser.getUrls(start_url)
            for url in urls:
                if url not in visited:
                    if url.startswith(include_pattern):
                        visited.add(url)
                        q.append(url)
        return list(visited)
```

### 1136. Parallel Courses

```python 
class Solution:
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        g, indegree = defaultdict(list), [0] * (n + 1) 
        for a, b in relations:
            g[a].append(b)
            indegree[b] += 1

        q = deque([i for i, v in enumerate(indegree) if v == 0 and i != 0])
        res, cnt = 0, 0
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                cnt += 1
                for nei in g[node]:
                    indegree[nei] -= 1
                    if indegree[nei] == 0:
                        q.append(nei)
            res += 1
        return res if cnt == n else -1
```

### 490. The Maze

```python 
class Solution:
    def hasPath(self, maze: List[List[int]], start: List[int], destination: List[int]) -> bool:
        def check(r, c, dr, dc):
            while 0 <= r < R and 0 <= c < C and maze[r][c] != 1:
                r += dr 
                c += dc 
            return r - dr, c - dc

        q = deque([tuple(start)])
        visited = set([tuple(start)])
        R, C = len(maze), len(maze[0])
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]
        while q:
            r, c = q.popleft()
            if [r, c] == destination:
                return True
            for dr, dc in directions:
                row, col = check(r, c, dr, dc)
                if (row, col) not in visited:
                    visited.add((row, col))
                    q.append((row, col))
        return False
```

### 286. Walls and Gates

```python 
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        R, C, INF = len(rooms), len(rooms[0]), 2147483647
        q = deque()
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for r in range(R):
            for c in range(C):
                if rooms[r][c] == 0:
                    q.append((r, c))

        while q:
            r, c = q.popleft()
            for dr, dc in directions:
                row, col = r + dr, c + dc
                if 0 <= row < R and 0 <= col < C and rooms[row][col] == INF:
                    q.append((row, col))
                    rooms[row][col] = rooms[r][c] + 1
        return rooms
```

### 1086. High Five

```python
class Solution:
    def highFive(self, items: List[List[int]]) -> List[List[int]]:
        d = defaultdict(list)
        for id, score in items:
            d[id].append(score)

        res = []
        for id, scores in d.items():
            res.append([id, sum(sorted(scores, reverse = True)[: 5]) // 5])
        res.sort()
        return res
```

### 1167. Minimum Cost to Connect Sticks

```python 
class Solution:
    def connectSticks(self, sticks: List[int]) -> int:
        heapify(sticks)
        res = 0
        while len(sticks) > 1:
            a, b = heappop(sticks), heappop(sticks)
            heappush(sticks, a + b)
            res += a + b 
        return res
```

### 1057. Campus Bikes

```python 
class Solution:
    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -> List[int]:
        res = []
        for i, a in enumerate(workers):
            for j, b in enumerate(bikes):
                res.append((abs(a[0]-b[0]) + abs(a[1]-b[1]), i, j))
        res.sort()

        work_set, bike_set = set(), set()
        ans = [0]*len(workers)
        for _, a, b in res:
            if a not in work_set and b not in bike_set:
                ans[a] = b
                work_set.add(a)
                bike_set.add(b)
        return ans
```

### 358. Rearrange String k Distance Apart

```python 
class Solution:
    def rearrangeString(self, s: str, k: int) -> str:
        if k == 0:
            return s
        
        d = collections.Counter(s)
        maxHeap = [(-1 * freq, c) for c, freq in d.items()]
        heapify(maxHeap)
        q, res = deque(), ''
        while maxHeap:
            freq, c = heappop(maxHeap) 
            freq *= -1
            res += c
            q.append((freq - 1, c))
            if len(q) == k:  
                f, c = q.popleft()
                if f > 0:
                    heappush(maxHeap, (-1 * f, c))
        
        return res if len(res) == len(s) else ""
```

### 1228. Missing Number In Arithmetic Progression

```python
class Solution:
    def missingNumber(self, arr: List[int]) -> int:
        arr.sort()
        n = len(arr)
        d = (arr[-1] - arr[0]) // n 
        return (n + 1) * (arr[0] + arr[-1]) // 2 - sum(arr)
```

### 1533. Find the Index of the Large Integer

```python 
class Solution:
    def getIndex(self, reader: 'ArrayReader') -> int:
        l, r = 0, reader.length() - 1
        while l <= r:
            m = (l + r) // 2
            if (l + r) % 2 == 0:
                res = reader.compareSub(l, m, m, r)
                if res == -1:
                    l = m + 1
                elif res == 1:
                    r = m - 1
                else:
                    return m 
            else:
                res = res = reader.compareSub(l, m, m + 1, r)
                if res == -1:
                    l = m + 1
                elif res == 1:
                    r = m
```

### 588. Design In-Memory File System

```python 
from sortedcontainers import SortedList
class FileSystem:

    def __init__(self):
        self.paths = defaultdict(SortedList)
        self.files = defaultdict(str)

    def ls(self, path: str) -> List[str]:
        if path in self.files:
            return [path.split('/')[-1]]
        else:
            return list(self.paths[path])

    def mkdir(self, path: str) -> None:
        directories = path.split('/')
        for i in range(1, len(directories)):
            cur = '/'.join(directories[:i]) or '/' # can be empty ''
            if cur not in self.paths or directories[i] not in self.paths[cur]:
                self.paths[cur].add(directories[i])

    def addContentToFile(self, filePath: str, content: str) -> None:
        if filePath not in self.files:
            self.mkdir(filePath)
        self.files[filePath] += content 

    def readContentFromFile(self, filePath: str) -> str:
        return self.files[filePath]
```